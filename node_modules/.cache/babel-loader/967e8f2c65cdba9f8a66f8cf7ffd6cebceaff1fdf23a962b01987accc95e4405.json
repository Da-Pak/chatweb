{"ast":null,"code":"import _objectSpread from\"C:/Users/sungh/Desktop/chat_work_ver2/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useState}from'react';import{sentenceApi}from'../../training/api/sentenceApi';import{useToast}from'./useToast';import{useClipboard}from'./useClipboard';export const useSentenceMenu=_ref=>{let{personaId,threadType,selectedThread,memos,highlightedSentences,setMemos,setHighlightedSentences}=_ref;const{showCopyToast}=useToast();const{copyTextToClipboard}=useClipboard();const[selectedSentences,setSelectedSentences]=useState(new Set());const handleSaveToVault=async(selectedIds,selectedTexts)=>{try{if(!selectedTexts.length){showCopyToast('저장할 문장을 선택해주세요');return;}if(!(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id)){showCopyToast('저장할 스레드를 선택해주세요');return;}// 하이라이트/메모 상태 수집\nconst highlightStates=[];const highlightColors=[];const memoContents=[];// 메모가 있는 문장들 찾기 (연관된 문장들과 함께)\nlet hasMemo=false;let memoSentenceId='';let memoContent='';let relatedSentenceIds=[];let relatedSentenceContents=[];for(const sentenceId of selectedIds){const isHighlighted=highlightedSentences.has(sentenceId);const currentMemoContent=memos[sentenceId]||null;highlightStates.push(isHighlighted);highlightColors.push(isHighlighted?'yellow':null);memoContents.push(currentMemoContent);// 메모가 있는 문장을 찾으면 관련 정보 수집\nif(currentMemoContent&&currentMemoContent.trim()!==''){hasMemo=true;memoSentenceId=sentenceId;memoContent=currentMemoContent;relatedSentenceIds=selectedIds;// 선택된 모든 문장이 연관됨\nrelatedSentenceContents=selectedTexts;}}// 일반 저장고 저장 (기존 로직)\nawait sentenceApi.saveSentencesToVault({sentences:selectedTexts,source_message_id:\"\".concat(threadType,\"_\").concat(personaId),source_conversation_id:selectedThread.id,source_thread_id:selectedThread.id,source_thread_type:threadType,source_sentence_ids:selectedIds,tags:[threadType,personaId],highlight_states:highlightStates,highlight_colors:highlightColors,memo_contents:memoContents});// 메모가 있는 경우 메모 저장고에도 별도 저장 (연관된 문장들과 함께)\nif(hasMemo){console.log('=== 메모 저장고 저장 ===');console.log('메모 문장 ID:',memoSentenceId);console.log('메모 내용:',memoContent);console.log('연관된 문장들:',relatedSentenceContents);try{await sentenceApi.saveMemoToVault({memo_content:memoContent,sentence_content:relatedSentenceContents.length>1?relatedSentenceContents.map(s=>\"\\\"\".concat(s,\"\\\"\")).join(', ')// 여러 문장인 경우\n:relatedSentenceContents[0]||'',// 단일 문장인 경우\nsource_message_id:\"\".concat(threadType,\"_\").concat(personaId),source_conversation_id:selectedThread.id,source_thread_id:selectedThread.id,source_thread_type:threadType,source_sentence_id:memoSentenceId,tags:[threadType,personaId],metadata:{related_sentence_ids:relatedSentenceIds,related_sentence_contents:relatedSentenceContents,memo_type:relatedSentenceContents.length>1?'multi_sentence':'single_sentence'}});console.log('메모 저장고 저장 완료');}catch(error){console.error('메모 저장고 저장 실패:',error);}}// 백엔드에 하이라이트도 저장\nfor(const sentenceId of selectedIds){await sentenceApi.createHighlight({sentence_id:sentenceId,thread_id:selectedThread.id,thread_type:threadType});}// 성공 시 로컬 상태 업데이트\nsetHighlightedSentences(prev=>new Set([...Array.from(prev),...selectedIds]));if(hasMemo){showCopyToast('저장고에 저장되었습니다 (메모와 연관 문장들 포함)');}else{showCopyToast('저장고에 저장되었습니다 (하이라이트 정보 포함)');}}catch(error){console.error('저장고 저장 실패:',error);showCopyToast('저장고 저장에 실패했습니다');}};const handleAddMemo=async(selectedIds,selectedTexts)=>{if(selectedIds.length===0)return;try{// 백엔드에 모든 선택된 문장의 하이라이트 저장\nif(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id){for(const sentenceId of selectedIds){await sentenceApi.createHighlight({sentence_id:sentenceId,thread_id:selectedThread.id,thread_type:threadType});}}// 마지막 문장 ID 찾기 (가장 큰 인덱스)\nconst sortedIds=selectedIds.sort();const lastSentenceId=sortedIds[sortedIds.length-1];// 마지막 문장에만 빈 메모 추가\nconst newMemos={[lastSentenceId]:''};// 메모에 연관된 문장들 정보 저장 (메타데이터로)\nconst relatedSentenceIds=selectedIds;const relatedSentenceTexts=selectedTexts;console.log('=== 메모 생성 정보 ===');console.log('마지막 문장 ID:',lastSentenceId);console.log('연관된 문장 ID들:',relatedSentenceIds);console.log('연관된 문장 텍스트들:',relatedSentenceTexts);// 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\nif(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id){try{await sentenceApi.createOrUpdateMemo({sentence_id:lastSentenceId,thread_id:selectedThread.id,thread_type:threadType,content:'',// 빈 메모로 시작\nrelated_sentence_ids:relatedSentenceIds,related_sentence_contents:relatedSentenceTexts,sentence_content:selectedTexts[selectedTexts.length-1],// 마지막 문장 내용\nsource_message_id:\"\".concat(threadType,\"_memo_\").concat(Date.now())});}catch(error){console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):',error);}}// 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\nsetMemos(prev=>_objectSpread(_objectSpread({},prev),newMemos));setHighlightedSentences(prev=>new Set([...Array.from(prev),...selectedIds]));// 선택된 문장이 여러 개인 경우 안내 메시지\nif(selectedIds.length>1){showCopyToast(\"\\uBA54\\uBAA8\\uAC00 \\uB9C8\\uC9C0\\uB9C9 \\uBB38\\uC7A5\\uC5D0 \\uC0DD\\uC131\\uB418\\uC5C8\\uC2B5\\uB2C8\\uB2E4 (\\uC5F0\\uAD00 \\uBB38\\uC7A5: \".concat(selectedIds.length,\"\\uAC1C)\"));}else{showCopyToast('메모와 하이라이트가 추가되었습니다');}}catch(error){console.error('메모/하이라이트 추가 실패:',error);showCopyToast('메모/하이라이트 추가에 실패했습니다');}};const handleToggleHighlight=async selectedIds=>{if(!selectedIds.length||!(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id))return;try{const currentlyHighlighted=selectedIds.filter(id=>highlightedSentences.has(id));if(currentlyHighlighted.length>0){// 하이라이트 제거\nsetHighlightedSentences(prev=>{const newSet=new Set(prev);selectedIds.forEach(id=>newSet.delete(id));return newSet;});// 백엔드에서 하이라이트 삭제\nfor(const sentenceId of selectedIds){try{await sentenceApi.deleteHighlight(sentenceId);}catch(error){console.warn('백엔드 하이라이트 삭제 실패:',error);}}showCopyToast('하이라이트가 제거되었습니다');}else{// 하이라이트 추가\nsetHighlightedSentences(prev=>new Set([...Array.from(prev),...selectedIds]));// 백엔드에 하이라이트 저장\nfor(const sentenceId of selectedIds){try{await sentenceApi.createHighlight({sentence_id:sentenceId,thread_id:selectedThread.id,thread_type:threadType});}catch(error){console.warn('백엔드 하이라이트 저장 실패:',error);}}showCopyToast('하이라이트가 추가되었습니다');}}catch(error){console.error('하이라이트 토글 실패:',error);showCopyToast('하이라이트 처리에 실패했습니다');}};const handleMenuAction=async(action,selectedIds,selectedTexts,messageInputRef)=>{switch(action){case'sendToInput':if(messageInputRef!==null&&messageInputRef!==void 0&&messageInputRef.current&&selectedTexts.length>0){const formattedText=selectedTexts.map(text=>\"\\\"\".concat(text,\"\\\"\")).join(', ');messageInputRef.current.insertText(formattedText);showCopyToast('선택한 문장이 입력창에 추가되었습니다');}break;case'saveToVault':await handleSaveToVault(selectedIds,selectedTexts);break;case'addMemo':await handleAddMemo(selectedIds,selectedTexts);break;case'highlight':await handleToggleHighlight(selectedIds);break;case'copy':if(selectedTexts.length>0){await copyTextToClipboard(selectedTexts.join(' '),'선택된 문장이 복사되었습니다');}break;}// 모든 선택 해제\nsetSelectedSentences(new Set());};return{selectedSentences,setSelectedSentences,handleMenuAction,handleSaveToVault,handleAddMemo,handleToggleHighlight};};","map":{"version":3,"names":["useState","sentenceApi","useToast","useClipboard","useSentenceMenu","_ref","personaId","threadType","selectedThread","memos","highlightedSentences","setMemos","setHighlightedSentences","showCopyToast","copyTextToClipboard","selectedSentences","setSelectedSentences","Set","handleSaveToVault","selectedIds","selectedTexts","length","id","highlightStates","highlightColors","memoContents","hasMemo","memoSentenceId","memoContent","relatedSentenceIds","relatedSentenceContents","sentenceId","isHighlighted","has","currentMemoContent","push","trim","saveSentencesToVault","sentences","source_message_id","concat","source_conversation_id","source_thread_id","source_thread_type","source_sentence_ids","tags","highlight_states","highlight_colors","memo_contents","console","log","saveMemoToVault","memo_content","sentence_content","map","s","join","source_sentence_id","metadata","related_sentence_ids","related_sentence_contents","memo_type","error","createHighlight","sentence_id","thread_id","thread_type","prev","Array","from","handleAddMemo","sortedIds","sort","lastSentenceId","newMemos","relatedSentenceTexts","createOrUpdateMemo","content","Date","now","warn","_objectSpread","handleToggleHighlight","currentlyHighlighted","filter","newSet","forEach","delete","deleteHighlight","handleMenuAction","action","messageInputRef","current","formattedText","text","insertText"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/shared/hooks/useSentenceMenu.ts"],"sourcesContent":["import { useState } from 'react';\nimport { sentenceApi } from '../../training/api/sentenceApi';\nimport { useToast } from './useToast';\nimport { useClipboard } from './useClipboard';\nimport { TrainingThread } from '../types';\n\ninterface UseSentenceMenuProps {\n  personaId: string;\n  threadType: 'interpretation' | 'proceed' | 'sentence' | 'verbalization';\n  selectedThread?: TrainingThread | null;\n  memos: Record<string, string>;\n  highlightedSentences: Set<string>;\n  setMemos: React.Dispatch<React.SetStateAction<Record<string, string>>>;\n  setHighlightedSentences: React.Dispatch<React.SetStateAction<Set<string>>>;\n}\n\nexport const useSentenceMenu = ({\n  personaId,\n  threadType,\n  selectedThread,\n  memos,\n  highlightedSentences,\n  setMemos,\n  setHighlightedSentences\n}: UseSentenceMenuProps) => {\n  const { showCopyToast } = useToast();\n  const { copyTextToClipboard } = useClipboard();\n  const [selectedSentences, setSelectedSentences] = useState<Set<string>>(new Set());\n\n  const handleSaveToVault = async (selectedIds: string[], selectedTexts: string[]) => {\n    try {\n      if (!selectedTexts.length) {\n        showCopyToast('저장할 문장을 선택해주세요');\n        return;\n      }\n\n      if (!selectedThread?.id) {\n        showCopyToast('저장할 스레드를 선택해주세요');\n        return;\n      }\n\n      // 하이라이트/메모 상태 수집\n      const highlightStates: boolean[] = [];\n      const highlightColors: (string | null)[] = [];\n      const memoContents: (string | null)[] = [];\n      \n      // 메모가 있는 문장들 찾기 (연관된 문장들과 함께)\n      let hasMemo = false;\n      let memoSentenceId = '';\n      let memoContent = '';\n      let relatedSentenceIds: string[] = [];\n      let relatedSentenceContents: string[] = [];\n      \n      for (const sentenceId of selectedIds) {\n        const isHighlighted = highlightedSentences.has(sentenceId);\n        const currentMemoContent = memos[sentenceId] || null;\n        \n        highlightStates.push(isHighlighted);\n        highlightColors.push(isHighlighted ? 'yellow' : null);\n        memoContents.push(currentMemoContent);\n        \n        // 메모가 있는 문장을 찾으면 관련 정보 수집\n        if (currentMemoContent && currentMemoContent.trim() !== '') {\n          hasMemo = true;\n          memoSentenceId = sentenceId;\n          memoContent = currentMemoContent;\n          relatedSentenceIds = selectedIds; // 선택된 모든 문장이 연관됨\n          relatedSentenceContents = selectedTexts;\n        }\n      }\n\n      // 일반 저장고 저장 (기존 로직)\n      await sentenceApi.saveSentencesToVault({\n        sentences: selectedTexts,\n        source_message_id: `${threadType}_${personaId}`,\n        source_conversation_id: selectedThread.id,\n        source_thread_id: selectedThread.id,\n        source_thread_type: threadType,\n        source_sentence_ids: selectedIds,\n        tags: [threadType, personaId],\n        highlight_states: highlightStates,\n        highlight_colors: highlightColors,\n        memo_contents: memoContents\n      });\n      \n      // 메모가 있는 경우 메모 저장고에도 별도 저장 (연관된 문장들과 함께)\n      if (hasMemo) {\n        console.log('=== 메모 저장고 저장 ===');\n        console.log('메모 문장 ID:', memoSentenceId);\n        console.log('메모 내용:', memoContent);\n        console.log('연관된 문장들:', relatedSentenceContents);\n        \n        try {\n          await sentenceApi.saveMemoToVault({\n            memo_content: memoContent,\n            sentence_content: relatedSentenceContents.length > 1 \n              ? relatedSentenceContents.map(s => `\"${s}\"`).join(', ')  // 여러 문장인 경우\n              : relatedSentenceContents[0] || '', // 단일 문장인 경우\n            source_message_id: `${threadType}_${personaId}`,\n            source_conversation_id: selectedThread.id,\n            source_thread_id: selectedThread.id,\n            source_thread_type: threadType,\n            source_sentence_id: memoSentenceId,\n            tags: [threadType, personaId],\n            metadata: {\n              related_sentence_ids: relatedSentenceIds,\n              related_sentence_contents: relatedSentenceContents,\n              memo_type: relatedSentenceContents.length > 1 ? 'multi_sentence' : 'single_sentence'\n            }\n          });\n          console.log('메모 저장고 저장 완료');\n        } catch (error) {\n          console.error('메모 저장고 저장 실패:', error);\n        }\n      }\n      \n      // 백엔드에 하이라이트도 저장\n      for (const sentenceId of selectedIds) {\n        await sentenceApi.createHighlight({\n          sentence_id: sentenceId,\n          thread_id: selectedThread.id,\n          thread_type: threadType\n        });\n      }\n      \n      // 성공 시 로컬 상태 업데이트\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      if (hasMemo) {\n        showCopyToast('저장고에 저장되었습니다 (메모와 연관 문장들 포함)');\n      } else {\n        showCopyToast('저장고에 저장되었습니다 (하이라이트 정보 포함)');\n      }\n    } catch (error) {\n      console.error('저장고 저장 실패:', error);\n      showCopyToast('저장고 저장에 실패했습니다');\n    }\n  };\n\n  const handleAddMemo = async (selectedIds: string[], selectedTexts: string[]) => {\n    if (selectedIds.length === 0) return;\n\n    try {\n      // 백엔드에 모든 선택된 문장의 하이라이트 저장\n      if (selectedThread?.id) {\n        for (const sentenceId of selectedIds) {\n          await sentenceApi.createHighlight({\n            sentence_id: sentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType\n          });\n        }\n      }\n      \n      // 마지막 문장 ID 찾기 (가장 큰 인덱스)\n      const sortedIds = selectedIds.sort();\n      const lastSentenceId = sortedIds[sortedIds.length - 1];\n      \n      // 마지막 문장에만 빈 메모 추가\n      const newMemos: Record<string, string> = {\n        [lastSentenceId]: ''\n      };\n      \n      // 메모에 연관된 문장들 정보 저장 (메타데이터로)\n      const relatedSentenceIds = selectedIds;\n      const relatedSentenceTexts = selectedTexts;\n      \n      console.log('=== 메모 생성 정보 ===');\n      console.log('마지막 문장 ID:', lastSentenceId);\n      console.log('연관된 문장 ID들:', relatedSentenceIds);\n      console.log('연관된 문장 텍스트들:', relatedSentenceTexts);\n      \n      // 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\n      if (selectedThread?.id) {\n        try {\n          await sentenceApi.createOrUpdateMemo({\n            sentence_id: lastSentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType,\n            content: '', // 빈 메모로 시작\n            related_sentence_ids: relatedSentenceIds,\n            related_sentence_contents: relatedSentenceTexts,\n            sentence_content: selectedTexts[selectedTexts.length - 1], // 마지막 문장 내용\n            source_message_id: `${threadType}_memo_${Date.now()}`\n          } as any);\n        } catch (error) {\n          console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):', error);\n        }\n      }\n      \n      // 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\n      setMemos(prev => ({ ...prev, ...newMemos }));\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      // 선택된 문장이 여러 개인 경우 안내 메시지\n      if (selectedIds.length > 1) {\n        showCopyToast(`메모가 마지막 문장에 생성되었습니다 (연관 문장: ${selectedIds.length}개)`);\n      } else {\n        showCopyToast('메모와 하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('메모/하이라이트 추가 실패:', error);\n      showCopyToast('메모/하이라이트 추가에 실패했습니다');\n    }\n  };\n\n  const handleToggleHighlight = async (selectedIds: string[]) => {\n    if (!selectedIds.length || !selectedThread?.id) return;\n\n    try {\n      const currentlyHighlighted = selectedIds.filter(id => highlightedSentences.has(id));\n      \n      if (currentlyHighlighted.length > 0) {\n        // 하이라이트 제거\n        setHighlightedSentences(prev => {\n          const newSet = new Set(prev);\n          selectedIds.forEach(id => newSet.delete(id));\n          return newSet;\n        });\n        \n        // 백엔드에서 하이라이트 삭제\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.deleteHighlight(sentenceId);\n          } catch (error) {\n            console.warn('백엔드 하이라이트 삭제 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 제거되었습니다');\n      } else {\n        // 하이라이트 추가\n        setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n        \n        // 백엔드에 하이라이트 저장\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.createHighlight({\n              sentence_id: sentenceId,\n              thread_id: selectedThread.id,\n              thread_type: threadType\n            });\n          } catch (error) {\n            console.warn('백엔드 하이라이트 저장 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('하이라이트 토글 실패:', error);\n      showCopyToast('하이라이트 처리에 실패했습니다');\n    }\n  };\n\n  const handleMenuAction = async (\n    action: 'sendToInput' | 'saveToVault' | 'addMemo' | 'highlight' | 'copy',\n    selectedIds: string[],\n    selectedTexts: string[],\n    messageInputRef?: React.RefObject<any>\n  ) => {\n    switch (action) {\n      case 'sendToInput':\n        if (messageInputRef?.current && selectedTexts.length > 0) {\n          const formattedText = selectedTexts.map(text => `\"${text}\"`).join(', ');\n          messageInputRef.current.insertText(formattedText);\n          showCopyToast('선택한 문장이 입력창에 추가되었습니다');\n        }\n        break;\n      \n      case 'saveToVault':\n        await handleSaveToVault(selectedIds, selectedTexts);\n        break;\n      \n      case 'addMemo':\n        await handleAddMemo(selectedIds, selectedTexts);\n        break;\n      \n      case 'highlight':\n        await handleToggleHighlight(selectedIds);\n        break;\n      \n      case 'copy':\n        if (selectedTexts.length > 0) {\n          await copyTextToClipboard(selectedTexts.join(' '), '선택된 문장이 복사되었습니다');\n        }\n        break;\n    }\n\n    // 모든 선택 해제\n    setSelectedSentences(new Set());\n  };\n\n  return {\n    selectedSentences,\n    setSelectedSentences,\n    handleMenuAction,\n    handleSaveToVault,\n    handleAddMemo,\n    handleToggleHighlight\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}