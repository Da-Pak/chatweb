{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback } from 'react';\nimport axios from 'axios';\nexport const useWhisper = onTranscriptUpdate => {\n  _s();\n  const [status, setStatus] = useState('idle');\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const startRecording = useCallback(async () => {\n    if (status === 'recording') return;\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      mediaRecorderRef.current = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n      audioChunksRef.current = [];\n      mediaRecorderRef.current.ondataavailable = event => {\n        audioChunksRef.current.push(event.data);\n      };\n      mediaRecorderRef.current.onstop = async () => {\n        setStatus('processing');\n        const audioBlob = new Blob(audioChunksRef.current, {\n          type: 'audio/webm'\n        });\n        const formData = new FormData();\n        formData.append('audio_file', audioBlob, 'recording.webm');\n        try {\n          const response = await axios.post('/api/stt', formData, {\n            headers: {\n              'Content-Type': 'multipart/form-data'\n            }\n          });\n          onTranscriptUpdate(response.data.text);\n          setStatus('idle');\n        } catch (error) {\n          console.error(\"음성 변환 실패:\", error);\n          setStatus('error');\n        }\n      };\n      mediaRecorderRef.current.start();\n      setStatus('recording');\n    } catch (error) {\n      console.error(\"마이크 접근 실패:\", error);\n      setStatus('error');\n    }\n  }, [status, onTranscriptUpdate]);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && status === 'recording') {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n    }\n  }, [status]);\n  return {\n    status,\n    startRecording,\n    stopRecording\n  };\n};\n_s(useWhisper, \"7caDp/iFFazi3iN4GwKQvHPZl0s=\");","map":{"version":3,"names":["useState","useRef","useCallback","axios","useWhisper","onTranscriptUpdate","_s","status","setStatus","mediaRecorderRef","audioChunksRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","current","MediaRecorder","mimeType","ondataavailable","event","push","data","onstop","audioBlob","Blob","type","formData","FormData","append","response","post","headers","text","error","console","start","stopRecording","stop","getTracks","forEach","track"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/qa/hooks/useWhisper.ts"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\r\nimport axios from 'axios';\r\n\r\nexport type RecordingStatus = 'idle' | 'recording' | 'processing' | 'error';\r\n\r\nexport const useWhisper = (onTranscriptUpdate: (text: string) => void) => {\r\n    const [status, setStatus] = useState<RecordingStatus>('idle');\r\n    const mediaRecorderRef = useRef<MediaRecorder | null>(null);\r\n    const audioChunksRef = useRef<Blob[]>([]);\r\n\r\n    const startRecording = useCallback(async () => {\r\n        if (status === 'recording') return;\r\n\r\n        try {\r\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n            mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: 'audio/webm' });\r\n            audioChunksRef.current = [];\r\n\r\n            mediaRecorderRef.current.ondataavailable = (event) => {\r\n                audioChunksRef.current.push(event.data);\r\n            };\r\n\r\n            mediaRecorderRef.current.onstop = async () => {\r\n                setStatus('processing');\r\n                const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\r\n                const formData = new FormData();\r\n                formData.append('audio_file', audioBlob, 'recording.webm');\r\n\r\n                try {\r\n                    const response = await axios.post('/api/stt', formData, {\r\n                        headers: { 'Content-Type': 'multipart/form-data' },\r\n                    });\r\n                    onTranscriptUpdate(response.data.text);\r\n                    setStatus('idle');\r\n                } catch (error) {\r\n                    console.error(\"음성 변환 실패:\", error);\r\n                    setStatus('error');\r\n                }\r\n            };\r\n\r\n            mediaRecorderRef.current.start();\r\n            setStatus('recording');\r\n        } catch (error) {\r\n            console.error(\"마이크 접근 실패:\", error);\r\n            setStatus('error');\r\n        }\r\n    }, [status, onTranscriptUpdate]);\r\n\r\n    const stopRecording = useCallback(() => {\r\n        if (mediaRecorderRef.current && status === 'recording') {\r\n            mediaRecorderRef.current.stop();\r\n            mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\r\n        }\r\n    }, [status]);\r\n\r\n    return { status, startRecording, stopRecording };\r\n}; "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AACrD,OAAOC,KAAK,MAAM,OAAO;AAIzB,OAAO,MAAMC,UAAU,GAAIC,kBAA0C,IAAK;EAAAC,EAAA;EACtE,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGR,QAAQ,CAAkB,MAAM,CAAC;EAC7D,MAAMS,gBAAgB,GAAGR,MAAM,CAAuB,IAAI,CAAC;EAC3D,MAAMS,cAAc,GAAGT,MAAM,CAAS,EAAE,CAAC;EAEzC,MAAMU,cAAc,GAAGT,WAAW,CAAC,YAAY;IAC3C,IAAIK,MAAM,KAAK,WAAW,EAAE;IAE5B,IAAI;MACA,MAAMK,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzEP,gBAAgB,CAACQ,OAAO,GAAG,IAAIC,aAAa,CAACN,MAAM,EAAE;QAAEO,QAAQ,EAAE;MAAa,CAAC,CAAC;MAChFT,cAAc,CAACO,OAAO,GAAG,EAAE;MAE3BR,gBAAgB,CAACQ,OAAO,CAACG,eAAe,GAAIC,KAAK,IAAK;QAClDX,cAAc,CAACO,OAAO,CAACK,IAAI,CAACD,KAAK,CAACE,IAAI,CAAC;MAC3C,CAAC;MAEDd,gBAAgB,CAACQ,OAAO,CAACO,MAAM,GAAG,YAAY;QAC1ChB,SAAS,CAAC,YAAY,CAAC;QACvB,MAAMiB,SAAS,GAAG,IAAIC,IAAI,CAAChB,cAAc,CAACO,OAAO,EAAE;UAAEU,IAAI,EAAE;QAAa,CAAC,CAAC;QAC1E,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;QAC/BD,QAAQ,CAACE,MAAM,CAAC,YAAY,EAAEL,SAAS,EAAE,gBAAgB,CAAC;QAE1D,IAAI;UACA,MAAMM,QAAQ,GAAG,MAAM5B,KAAK,CAAC6B,IAAI,CAAC,UAAU,EAAEJ,QAAQ,EAAE;YACpDK,OAAO,EAAE;cAAE,cAAc,EAAE;YAAsB;UACrD,CAAC,CAAC;UACF5B,kBAAkB,CAAC0B,QAAQ,CAACR,IAAI,CAACW,IAAI,CAAC;UACtC1B,SAAS,CAAC,MAAM,CAAC;QACrB,CAAC,CAAC,OAAO2B,KAAK,EAAE;UACZC,OAAO,CAACD,KAAK,CAAC,WAAW,EAAEA,KAAK,CAAC;UACjC3B,SAAS,CAAC,OAAO,CAAC;QACtB;MACJ,CAAC;MAEDC,gBAAgB,CAACQ,OAAO,CAACoB,KAAK,CAAC,CAAC;MAChC7B,SAAS,CAAC,WAAW,CAAC;IAC1B,CAAC,CAAC,OAAO2B,KAAK,EAAE;MACZC,OAAO,CAACD,KAAK,CAAC,YAAY,EAAEA,KAAK,CAAC;MAClC3B,SAAS,CAAC,OAAO,CAAC;IACtB;EACJ,CAAC,EAAE,CAACD,MAAM,EAAEF,kBAAkB,CAAC,CAAC;EAEhC,MAAMiC,aAAa,GAAGpC,WAAW,CAAC,MAAM;IACpC,IAAIO,gBAAgB,CAACQ,OAAO,IAAIV,MAAM,KAAK,WAAW,EAAE;MACpDE,gBAAgB,CAACQ,OAAO,CAACsB,IAAI,CAAC,CAAC;MAC/B9B,gBAAgB,CAACQ,OAAO,CAACL,MAAM,CAAC4B,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;IAC9E;EACJ,CAAC,EAAE,CAAChC,MAAM,CAAC,CAAC;EAEZ,OAAO;IAAEA,MAAM;IAAEI,cAAc;IAAE2B;EAAc,CAAC;AACpD,CAAC;AAAChC,EAAA,CAnDWF,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}