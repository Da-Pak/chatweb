{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from 'react';\nimport { sentenceApi } from '../../training/api/sentenceApi';\nimport { useToast } from './useToast';\nimport { useClipboard } from './useClipboard';\nexport const useSentenceMenu = ({\n  personaId,\n  threadType,\n  selectedThread,\n  memos,\n  highlightedSentences,\n  setMemos,\n  setHighlightedSentences\n}) => {\n  _s();\n  const {\n    showCopyToast\n  } = useToast();\n  const {\n    copyTextToClipboard\n  } = useClipboard();\n  const [selectedSentences, setSelectedSentences] = useState(new Set());\n  const handleSaveToVault = async (selectedIds, selectedTexts) => {\n    try {\n      if (!selectedTexts.length) {\n        showCopyToast('저장할 문장을 선택해주세요');\n        return;\n      }\n      if (!(selectedThread !== null && selectedThread !== void 0 && selectedThread.id)) {\n        showCopyToast('저장할 스레드를 선택해주세요');\n        return;\n      }\n\n      // 하이라이트/메모 상태 수집\n      const highlightStates = [];\n      const highlightColors = [];\n      const memoContents = [];\n      for (const sentenceId of selectedIds) {\n        const isHighlighted = highlightedSentences.has(sentenceId);\n        const memoContent = memos[sentenceId] || null;\n        highlightStates.push(isHighlighted);\n        highlightColors.push(isHighlighted ? 'yellow' : null);\n        memoContents.push(memoContent);\n      }\n      await sentenceApi.saveSentencesToVault({\n        sentences: selectedTexts,\n        source_message_id: `${threadType}_${personaId}`,\n        source_conversation_id: selectedThread.id,\n        source_thread_id: selectedThread.id,\n        source_thread_type: threadType,\n        source_sentence_ids: selectedIds,\n        tags: [threadType, personaId],\n        highlight_states: highlightStates,\n        highlight_colors: highlightColors,\n        memo_contents: memoContents\n      });\n\n      // 백엔드에 하이라이트도 저장\n      for (const sentenceId of selectedIds) {\n        await sentenceApi.createHighlight({\n          sentence_id: sentenceId,\n          thread_id: selectedThread.id,\n          thread_type: threadType\n        });\n      }\n\n      // 성공 시 로컬 상태 업데이트\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      showCopyToast('저장고에 저장되었습니다 (하이라이트/메모 정보 포함)');\n    } catch (error) {\n      console.error('저장고 저장 실패:', error);\n      showCopyToast('저장고 저장에 실패했습니다');\n    }\n  };\n  const handleAddMemo = async (selectedIds, selectedTexts) => {\n    if (selectedIds.length === 0) return;\n    try {\n      // 백엔드에 모든 선택된 문장의 하이라이트 저장\n      if (selectedThread !== null && selectedThread !== void 0 && selectedThread.id) {\n        for (const sentenceId of selectedIds) {\n          await sentenceApi.createHighlight({\n            sentence_id: sentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType\n          });\n        }\n      }\n\n      // 마지막 문장 ID 찾기 (가장 큰 인덱스)\n      const sortedIds = selectedIds.sort();\n      const lastSentenceId = sortedIds[sortedIds.length - 1];\n\n      // 마지막 문장에만 빈 메모 추가\n      const newMemos = {\n        [lastSentenceId]: ''\n      };\n\n      // 메모에 연관된 문장들 정보 저장 (메타데이터로)\n      const relatedSentenceIds = selectedIds;\n      const relatedSentenceTexts = selectedTexts;\n      console.log('=== 메모 생성 정보 ===');\n      console.log('마지막 문장 ID:', lastSentenceId);\n      console.log('연관된 문장 ID들:', relatedSentenceIds);\n      console.log('연관된 문장 텍스트들:', relatedSentenceTexts);\n\n      // 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\n      if (selectedThread !== null && selectedThread !== void 0 && selectedThread.id) {\n        try {\n          await sentenceApi.createOrUpdateMemo({\n            sentence_id: lastSentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType,\n            content: '',\n            // 빈 메모로 시작\n            related_sentence_ids: relatedSentenceIds,\n            related_sentence_contents: relatedSentenceTexts,\n            sentence_content: selectedTexts[selectedTexts.length - 1],\n            // 마지막 문장 내용\n            source_message_id: `${threadType}_memo_${Date.now()}`\n          });\n        } catch (error) {\n          console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):', error);\n        }\n      }\n\n      // 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\n      setMemos(prev => ({\n        ...prev,\n        ...newMemos\n      }));\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n\n      // 선택된 문장이 여러 개인 경우 안내 메시지\n      if (selectedIds.length > 1) {\n        showCopyToast(`메모가 마지막 문장에 생성되었습니다 (연관 문장: ${selectedIds.length}개)`);\n      } else {\n        showCopyToast('메모와 하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('메모/하이라이트 추가 실패:', error);\n      showCopyToast('메모/하이라이트 추가에 실패했습니다');\n    }\n  };\n  const handleToggleHighlight = async selectedIds => {\n    if (!selectedIds.length || !(selectedThread !== null && selectedThread !== void 0 && selectedThread.id)) return;\n    try {\n      const currentlyHighlighted = selectedIds.filter(id => highlightedSentences.has(id));\n      if (currentlyHighlighted.length > 0) {\n        // 하이라이트 제거\n        setHighlightedSentences(prev => {\n          const newSet = new Set(prev);\n          selectedIds.forEach(id => newSet.delete(id));\n          return newSet;\n        });\n\n        // 백엔드에서 하이라이트 삭제\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.deleteHighlight(sentenceId);\n          } catch (error) {\n            console.warn('백엔드 하이라이트 삭제 실패:', error);\n          }\n        }\n        showCopyToast('하이라이트가 제거되었습니다');\n      } else {\n        // 하이라이트 추가\n        setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n\n        // 백엔드에 하이라이트 저장\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.createHighlight({\n              sentence_id: sentenceId,\n              thread_id: selectedThread.id,\n              thread_type: threadType\n            });\n          } catch (error) {\n            console.warn('백엔드 하이라이트 저장 실패:', error);\n          }\n        }\n        showCopyToast('하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('하이라이트 토글 실패:', error);\n      showCopyToast('하이라이트 처리에 실패했습니다');\n    }\n  };\n  const handleMenuAction = async (action, selectedIds, selectedTexts, messageInputRef) => {\n    switch (action) {\n      case 'sendToInput':\n        if (messageInputRef !== null && messageInputRef !== void 0 && messageInputRef.current && selectedTexts.length > 0) {\n          const formattedText = selectedTexts.map(text => `\"${text}\"`).join(', ');\n          messageInputRef.current.insertText(formattedText);\n          showCopyToast('선택한 문장이 입력창에 추가되었습니다');\n        }\n        break;\n      case 'saveToVault':\n        await handleSaveToVault(selectedIds, selectedTexts);\n        break;\n      case 'addMemo':\n        await handleAddMemo(selectedIds, selectedTexts);\n        break;\n      case 'highlight':\n        await handleToggleHighlight(selectedIds);\n        break;\n      case 'copy':\n        if (selectedTexts.length > 0) {\n          await copyTextToClipboard(selectedTexts.join(' '), '선택된 문장이 복사되었습니다');\n        }\n        break;\n    }\n\n    // 모든 선택 해제\n    setSelectedSentences(new Set());\n  };\n  return {\n    selectedSentences,\n    setSelectedSentences,\n    handleMenuAction,\n    handleSaveToVault,\n    handleAddMemo,\n    handleToggleHighlight\n  };\n};\n_s(useSentenceMenu, \"vWxyXXC9dGXiW7mbLZphIa//f10=\", false, function () {\n  return [useToast, useClipboard];\n});","map":{"version":3,"names":["useState","sentenceApi","useToast","useClipboard","useSentenceMenu","personaId","threadType","selectedThread","memos","highlightedSentences","setMemos","setHighlightedSentences","_s","showCopyToast","copyTextToClipboard","selectedSentences","setSelectedSentences","Set","handleSaveToVault","selectedIds","selectedTexts","length","id","highlightStates","highlightColors","memoContents","sentenceId","isHighlighted","has","memoContent","push","saveSentencesToVault","sentences","source_message_id","source_conversation_id","source_thread_id","source_thread_type","source_sentence_ids","tags","highlight_states","highlight_colors","memo_contents","createHighlight","sentence_id","thread_id","thread_type","prev","Array","from","error","console","handleAddMemo","sortedIds","sort","lastSentenceId","newMemos","relatedSentenceIds","relatedSentenceTexts","log","createOrUpdateMemo","content","related_sentence_ids","related_sentence_contents","sentence_content","Date","now","warn","handleToggleHighlight","currentlyHighlighted","filter","newSet","forEach","delete","deleteHighlight","handleMenuAction","action","messageInputRef","current","formattedText","map","text","join","insertText"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/shared/hooks/useSentenceMenu.ts"],"sourcesContent":["import { useState } from 'react';\nimport { sentenceApi } from '../../training/api/sentenceApi';\nimport { useToast } from './useToast';\nimport { useClipboard } from './useClipboard';\nimport { TrainingThread } from '../types';\n\ninterface UseSentenceMenuProps {\n  personaId: string;\n  threadType: 'interpretation' | 'proceed' | 'sentence' | 'verbalization';\n  selectedThread?: TrainingThread | null;\n  memos: Record<string, string>;\n  highlightedSentences: Set<string>;\n  setMemos: React.Dispatch<React.SetStateAction<Record<string, string>>>;\n  setHighlightedSentences: React.Dispatch<React.SetStateAction<Set<string>>>;\n}\n\nexport const useSentenceMenu = ({\n  personaId,\n  threadType,\n  selectedThread,\n  memos,\n  highlightedSentences,\n  setMemos,\n  setHighlightedSentences\n}: UseSentenceMenuProps) => {\n  const { showCopyToast } = useToast();\n  const { copyTextToClipboard } = useClipboard();\n  const [selectedSentences, setSelectedSentences] = useState<Set<string>>(new Set());\n\n  const handleSaveToVault = async (selectedIds: string[], selectedTexts: string[]) => {\n    try {\n      if (!selectedTexts.length) {\n        showCopyToast('저장할 문장을 선택해주세요');\n        return;\n      }\n\n      if (!selectedThread?.id) {\n        showCopyToast('저장할 스레드를 선택해주세요');\n        return;\n      }\n\n      // 하이라이트/메모 상태 수집\n      const highlightStates: boolean[] = [];\n      const highlightColors: (string | null)[] = [];\n      const memoContents: (string | null)[] = [];\n      \n      for (const sentenceId of selectedIds) {\n        const isHighlighted = highlightedSentences.has(sentenceId);\n        const memoContent = memos[sentenceId] || null;\n        \n        highlightStates.push(isHighlighted);\n        highlightColors.push(isHighlighted ? 'yellow' : null);\n        memoContents.push(memoContent);\n      }\n\n      await sentenceApi.saveSentencesToVault({\n        sentences: selectedTexts,\n        source_message_id: `${threadType}_${personaId}`,\n        source_conversation_id: selectedThread.id,\n        source_thread_id: selectedThread.id,\n        source_thread_type: threadType,\n        source_sentence_ids: selectedIds,\n        tags: [threadType, personaId],\n        highlight_states: highlightStates,\n        highlight_colors: highlightColors,\n        memo_contents: memoContents\n      });\n      \n      // 백엔드에 하이라이트도 저장\n      for (const sentenceId of selectedIds) {\n        await sentenceApi.createHighlight({\n          sentence_id: sentenceId,\n          thread_id: selectedThread.id,\n          thread_type: threadType\n        });\n      }\n      \n      // 성공 시 로컬 상태 업데이트\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      showCopyToast('저장고에 저장되었습니다 (하이라이트/메모 정보 포함)');\n    } catch (error) {\n      console.error('저장고 저장 실패:', error);\n      showCopyToast('저장고 저장에 실패했습니다');\n    }\n  };\n\n  const handleAddMemo = async (selectedIds: string[], selectedTexts: string[]) => {\n    if (selectedIds.length === 0) return;\n\n    try {\n      // 백엔드에 모든 선택된 문장의 하이라이트 저장\n      if (selectedThread?.id) {\n        for (const sentenceId of selectedIds) {\n          await sentenceApi.createHighlight({\n            sentence_id: sentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType\n          });\n        }\n      }\n      \n      // 마지막 문장 ID 찾기 (가장 큰 인덱스)\n      const sortedIds = selectedIds.sort();\n      const lastSentenceId = sortedIds[sortedIds.length - 1];\n      \n      // 마지막 문장에만 빈 메모 추가\n      const newMemos: Record<string, string> = {\n        [lastSentenceId]: ''\n      };\n      \n      // 메모에 연관된 문장들 정보 저장 (메타데이터로)\n      const relatedSentenceIds = selectedIds;\n      const relatedSentenceTexts = selectedTexts;\n      \n      console.log('=== 메모 생성 정보 ===');\n      console.log('마지막 문장 ID:', lastSentenceId);\n      console.log('연관된 문장 ID들:', relatedSentenceIds);\n      console.log('연관된 문장 텍스트들:', relatedSentenceTexts);\n      \n      // 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\n      if (selectedThread?.id) {\n        try {\n          await sentenceApi.createOrUpdateMemo({\n            sentence_id: lastSentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType,\n            content: '', // 빈 메모로 시작\n            related_sentence_ids: relatedSentenceIds,\n            related_sentence_contents: relatedSentenceTexts,\n            sentence_content: selectedTexts[selectedTexts.length - 1], // 마지막 문장 내용\n            source_message_id: `${threadType}_memo_${Date.now()}`\n          } as any);\n        } catch (error) {\n          console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):', error);\n        }\n      }\n      \n      // 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\n      setMemos(prev => ({ ...prev, ...newMemos }));\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      // 선택된 문장이 여러 개인 경우 안내 메시지\n      if (selectedIds.length > 1) {\n        showCopyToast(`메모가 마지막 문장에 생성되었습니다 (연관 문장: ${selectedIds.length}개)`);\n      } else {\n        showCopyToast('메모와 하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('메모/하이라이트 추가 실패:', error);\n      showCopyToast('메모/하이라이트 추가에 실패했습니다');\n    }\n  };\n\n  const handleToggleHighlight = async (selectedIds: string[]) => {\n    if (!selectedIds.length || !selectedThread?.id) return;\n\n    try {\n      const currentlyHighlighted = selectedIds.filter(id => highlightedSentences.has(id));\n      \n      if (currentlyHighlighted.length > 0) {\n        // 하이라이트 제거\n        setHighlightedSentences(prev => {\n          const newSet = new Set(prev);\n          selectedIds.forEach(id => newSet.delete(id));\n          return newSet;\n        });\n        \n        // 백엔드에서 하이라이트 삭제\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.deleteHighlight(sentenceId);\n          } catch (error) {\n            console.warn('백엔드 하이라이트 삭제 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 제거되었습니다');\n      } else {\n        // 하이라이트 추가\n        setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n        \n        // 백엔드에 하이라이트 저장\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.createHighlight({\n              sentence_id: sentenceId,\n              thread_id: selectedThread.id,\n              thread_type: threadType\n            });\n          } catch (error) {\n            console.warn('백엔드 하이라이트 저장 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('하이라이트 토글 실패:', error);\n      showCopyToast('하이라이트 처리에 실패했습니다');\n    }\n  };\n\n  const handleMenuAction = async (\n    action: 'sendToInput' | 'saveToVault' | 'addMemo' | 'highlight' | 'copy',\n    selectedIds: string[],\n    selectedTexts: string[],\n    messageInputRef?: React.RefObject<any>\n  ) => {\n    switch (action) {\n      case 'sendToInput':\n        if (messageInputRef?.current && selectedTexts.length > 0) {\n          const formattedText = selectedTexts.map(text => `\"${text}\"`).join(', ');\n          messageInputRef.current.insertText(formattedText);\n          showCopyToast('선택한 문장이 입력창에 추가되었습니다');\n        }\n        break;\n      \n      case 'saveToVault':\n        await handleSaveToVault(selectedIds, selectedTexts);\n        break;\n      \n      case 'addMemo':\n        await handleAddMemo(selectedIds, selectedTexts);\n        break;\n      \n      case 'highlight':\n        await handleToggleHighlight(selectedIds);\n        break;\n      \n      case 'copy':\n        if (selectedTexts.length > 0) {\n          await copyTextToClipboard(selectedTexts.join(' '), '선택된 문장이 복사되었습니다');\n        }\n        break;\n    }\n\n    // 모든 선택 해제\n    setSelectedSentences(new Set());\n  };\n\n  return {\n    selectedSentences,\n    setSelectedSentences,\n    handleMenuAction,\n    handleSaveToVault,\n    handleAddMemo,\n    handleToggleHighlight\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}