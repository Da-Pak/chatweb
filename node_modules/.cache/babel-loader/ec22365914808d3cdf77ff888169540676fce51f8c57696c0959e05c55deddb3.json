{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from 'react';\nimport { sentenceApi } from '../../training/api/sentenceApi';\nimport { useToast } from './useToast';\nimport { useClipboard } from './useClipboard';\nexport const useSentenceMenu = ({\n  personaId,\n  threadType,\n  selectedThread,\n  memos,\n  highlightedSentences,\n  setMemos,\n  setHighlightedSentences\n}) => {\n  _s();\n  const {\n    showCopyToast\n  } = useToast();\n  const {\n    copyTextToClipboard\n  } = useClipboard();\n  const [selectedSentences, setSelectedSentences] = useState(new Set());\n  const handleSaveToVault = async (selectedIds, selectedTexts) => {\n    try {\n      if (!selectedTexts.length) {\n        showCopyToast('저장할 문장을 선택해주세요');\n        return;\n      }\n      if (!(selectedThread !== null && selectedThread !== void 0 && selectedThread.id)) {\n        showCopyToast('저장할 스레드를 선택해주세요');\n        return;\n      }\n\n      // 하이라이트/메모 상태 수집\n      const highlightStates = [];\n      const highlightColors = [];\n      const memoContents = [];\n\n      // 메모가 있는 문장들 찾기 (연관된 문장들과 함께)\n      let hasMemo = false;\n      let memoSentenceId = '';\n      let memoContent = '';\n      let relatedSentenceIds = [];\n      let relatedSentenceContents = [];\n      for (const sentenceId of selectedIds) {\n        const isHighlighted = highlightedSentences.has(sentenceId);\n        const currentMemoContent = memos[sentenceId] || null;\n        highlightStates.push(isHighlighted);\n        highlightColors.push(isHighlighted ? 'yellow' : null);\n        memoContents.push(currentMemoContent);\n\n        // 메모가 있는 문장을 찾으면 관련 정보 수집\n        if (currentMemoContent && currentMemoContent.trim() !== '') {\n          hasMemo = true;\n          memoSentenceId = sentenceId;\n          memoContent = currentMemoContent;\n          relatedSentenceIds = selectedIds; // 선택된 모든 문장이 연관됨\n          relatedSentenceContents = selectedTexts;\n        }\n      }\n\n      // 일반 저장고 저장 (기존 로직)\n      await sentenceApi.saveSentencesToVault({\n        sentences: selectedTexts,\n        source_message_id: `${threadType}_${personaId}`,\n        source_conversation_id: selectedThread.id,\n        source_thread_id: selectedThread.id,\n        source_thread_type: threadType,\n        source_sentence_ids: selectedIds,\n        tags: [threadType, personaId],\n        highlight_states: highlightStates,\n        highlight_colors: highlightColors,\n        memo_contents: memoContents\n      });\n\n      // 메모가 있는 경우 메모 저장고에도 별도 저장 (연관된 문장들과 함께)\n      if (hasMemo) {\n        console.log('=== 메모 저장고 저장 ===');\n        console.log('메모 문장 ID:', memoSentenceId);\n        console.log('메모 내용:', memoContent);\n        console.log('연관된 문장들:', relatedSentenceContents);\n        try {\n          await sentenceApi.saveMemoToVault({\n            memo_content: memoContent,\n            sentence_content: relatedSentenceContents.length > 1 ? relatedSentenceContents.map(s => `\"${s}\"`).join(', ') // 여러 문장인 경우\n            : relatedSentenceContents[0] || '',\n            // 단일 문장인 경우\n            source_message_id: `${threadType}_${personaId}`,\n            source_conversation_id: selectedThread.id,\n            source_thread_id: selectedThread.id,\n            source_thread_type: threadType,\n            source_sentence_id: memoSentenceId,\n            tags: [threadType, personaId],\n            metadata: {\n              related_sentence_ids: relatedSentenceIds,\n              related_sentence_contents: relatedSentenceContents,\n              memo_type: relatedSentenceContents.length > 1 ? 'multi_sentence' : 'single_sentence'\n            }\n          });\n          console.log('메모 저장고 저장 완료');\n        } catch (error) {\n          console.error('메모 저장고 저장 실패:', error);\n        }\n      }\n\n      // 백엔드에 하이라이트도 저장\n      for (const sentenceId of selectedIds) {\n        await sentenceApi.createHighlight({\n          sentence_id: sentenceId,\n          thread_id: selectedThread.id,\n          thread_type: threadType\n        });\n      }\n\n      // 성공 시 로컬 상태 업데이트\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      if (hasMemo) {\n        showCopyToast('저장고에 저장되었습니다 (메모와 연관 문장들 포함)');\n      } else {\n        showCopyToast('저장고에 저장되었습니다 (하이라이트 정보 포함)');\n      }\n    } catch (error) {\n      console.error('저장고 저장 실패:', error);\n      showCopyToast('저장고 저장에 실패했습니다');\n    }\n  };\n  const handleAddMemo = async (selectedIds, selectedTexts) => {\n    if (selectedIds.length === 0) return;\n    try {\n      // 백엔드에 모든 선택된 문장의 하이라이트 저장\n      if (selectedThread !== null && selectedThread !== void 0 && selectedThread.id) {\n        for (const sentenceId of selectedIds) {\n          await sentenceApi.createHighlight({\n            sentence_id: sentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType\n          });\n        }\n      }\n\n      // 마지막 문장 ID 찾기 (가장 큰 인덱스)\n      const sortedIds = selectedIds.sort();\n      const lastSentenceId = sortedIds[sortedIds.length - 1];\n\n      // 마지막 문장에만 빈 메모 추가\n      const newMemos = {\n        [lastSentenceId]: ''\n      };\n\n      // 메모에 연관된 문장들 정보 저장 (메타데이터로)\n      const relatedSentenceIds = selectedIds;\n      const relatedSentenceTexts = selectedTexts;\n      console.log('=== 메모 생성 정보 ===');\n      console.log('마지막 문장 ID:', lastSentenceId);\n      console.log('연관된 문장 ID들:', relatedSentenceIds);\n      console.log('연관된 문장 텍스트들:', relatedSentenceTexts);\n\n      // 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\n      if (selectedThread !== null && selectedThread !== void 0 && selectedThread.id) {\n        try {\n          await sentenceApi.createOrUpdateMemo({\n            sentence_id: lastSentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType,\n            content: '',\n            // 빈 메모로 시작\n            related_sentence_ids: relatedSentenceIds,\n            related_sentence_contents: relatedSentenceTexts,\n            sentence_content: selectedTexts[selectedTexts.length - 1],\n            // 마지막 문장 내용\n            source_message_id: `${threadType}_memo_${Date.now()}`\n          });\n        } catch (error) {\n          console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):', error);\n        }\n      }\n\n      // 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\n      setMemos(prev => ({\n        ...prev,\n        ...newMemos\n      }));\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n\n      // 선택된 문장이 여러 개인 경우 안내 메시지\n      if (selectedIds.length > 1) {\n        showCopyToast(`메모가 마지막 문장에 생성되었습니다 (연관 문장: ${selectedIds.length}개)`);\n      } else {\n        showCopyToast('메모와 하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('메모/하이라이트 추가 실패:', error);\n      showCopyToast('메모/하이라이트 추가에 실패했습니다');\n    }\n  };\n  const handleToggleHighlight = async selectedIds => {\n    if (!selectedIds.length || !(selectedThread !== null && selectedThread !== void 0 && selectedThread.id)) return;\n    try {\n      const currentlyHighlighted = selectedIds.filter(id => highlightedSentences.has(id));\n      if (currentlyHighlighted.length > 0) {\n        // 하이라이트 제거\n        setHighlightedSentences(prev => {\n          const newSet = new Set(prev);\n          selectedIds.forEach(id => newSet.delete(id));\n          return newSet;\n        });\n\n        // 백엔드에서 하이라이트 삭제\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.deleteHighlight(sentenceId);\n          } catch (error) {\n            console.warn('백엔드 하이라이트 삭제 실패:', error);\n          }\n        }\n        showCopyToast('하이라이트가 제거되었습니다');\n      } else {\n        // 하이라이트 추가\n        setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n\n        // 백엔드에 하이라이트 저장\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.createHighlight({\n              sentence_id: sentenceId,\n              thread_id: selectedThread.id,\n              thread_type: threadType\n            });\n          } catch (error) {\n            console.warn('백엔드 하이라이트 저장 실패:', error);\n          }\n        }\n        showCopyToast('하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('하이라이트 토글 실패:', error);\n      showCopyToast('하이라이트 처리에 실패했습니다');\n    }\n  };\n  const handleMenuAction = async (action, selectedIds, selectedTexts, messageInputRef) => {\n    switch (action) {\n      case 'sendToInput':\n        if (messageInputRef !== null && messageInputRef !== void 0 && messageInputRef.current && selectedTexts.length > 0) {\n          const formattedText = selectedTexts.map(text => `\"${text}\"`).join(', ');\n          messageInputRef.current.insertText(formattedText);\n          showCopyToast('선택한 문장이 입력창에 추가되었습니다');\n        }\n        break;\n      case 'saveToVault':\n        await handleSaveToVault(selectedIds, selectedTexts);\n        break;\n      case 'addMemo':\n        await handleAddMemo(selectedIds, selectedTexts);\n        break;\n      case 'highlight':\n        await handleToggleHighlight(selectedIds);\n        break;\n      case 'copy':\n        if (selectedTexts.length > 0) {\n          await copyTextToClipboard(selectedTexts.join(' '), '선택된 문장이 복사되었습니다');\n        }\n        break;\n    }\n\n    // 모든 선택 해제\n    setSelectedSentences(new Set());\n  };\n  return {\n    selectedSentences,\n    setSelectedSentences,\n    handleMenuAction,\n    handleSaveToVault,\n    handleAddMemo,\n    handleToggleHighlight\n  };\n};\n_s(useSentenceMenu, \"vWxyXXC9dGXiW7mbLZphIa//f10=\", false, function () {\n  return [useToast, useClipboard];\n});","map":{"version":3,"names":["useState","sentenceApi","useToast","useClipboard","useSentenceMenu","personaId","threadType","selectedThread","memos","highlightedSentences","setMemos","setHighlightedSentences","_s","showCopyToast","copyTextToClipboard","selectedSentences","setSelectedSentences","Set","handleSaveToVault","selectedIds","selectedTexts","length","id","highlightStates","highlightColors","memoContents","hasMemo","memoSentenceId","memoContent","relatedSentenceIds","relatedSentenceContents","sentenceId","isHighlighted","has","currentMemoContent","push","trim","saveSentencesToVault","sentences","source_message_id","source_conversation_id","source_thread_id","source_thread_type","source_sentence_ids","tags","highlight_states","highlight_colors","memo_contents","console","log","saveMemoToVault","memo_content","sentence_content","map","s","join","source_sentence_id","metadata","related_sentence_ids","related_sentence_contents","memo_type","error","createHighlight","sentence_id","thread_id","thread_type","prev","Array","from","handleAddMemo","sortedIds","sort","lastSentenceId","newMemos","relatedSentenceTexts","createOrUpdateMemo","content","Date","now","warn","handleToggleHighlight","currentlyHighlighted","filter","newSet","forEach","delete","deleteHighlight","handleMenuAction","action","messageInputRef","current","formattedText","text","insertText"],"sources":["C:/Users/sungh/Desktop/chat_work_ver4/frontend/src/features/shared/hooks/useSentenceMenu.ts"],"sourcesContent":["import { useState } from 'react';\nimport { sentenceApi } from '../../training/api/sentenceApi';\nimport { useToast } from './useToast';\nimport { useClipboard } from './useClipboard';\nimport { TrainingThread } from '../types';\n\ninterface UseSentenceMenuProps {\n  personaId: string;\n  threadType: 'interpretation' | 'proceed' | 'sentence' | 'verbalization';\n  selectedThread?: TrainingThread | null;\n  memos: Record<string, string>;\n  highlightedSentences: Set<string>;\n  setMemos: React.Dispatch<React.SetStateAction<Record<string, string>>>;\n  setHighlightedSentences: React.Dispatch<React.SetStateAction<Set<string>>>;\n}\n\nexport const useSentenceMenu = ({\n  personaId,\n  threadType,\n  selectedThread,\n  memos,\n  highlightedSentences,\n  setMemos,\n  setHighlightedSentences\n}: UseSentenceMenuProps) => {\n  const { showCopyToast } = useToast();\n  const { copyTextToClipboard } = useClipboard();\n  const [selectedSentences, setSelectedSentences] = useState<Set<string>>(new Set());\n\n  const handleSaveToVault = async (selectedIds: string[], selectedTexts: string[]) => {\n    try {\n      if (!selectedTexts.length) {\n        showCopyToast('저장할 문장을 선택해주세요');\n        return;\n      }\n\n      if (!selectedThread?.id) {\n        showCopyToast('저장할 스레드를 선택해주세요');\n        return;\n      }\n\n      // 하이라이트/메모 상태 수집\n      const highlightStates: boolean[] = [];\n      const highlightColors: (string | null)[] = [];\n      const memoContents: (string | null)[] = [];\n      \n      // 메모가 있는 문장들 찾기 (연관된 문장들과 함께)\n      let hasMemo = false;\n      let memoSentenceId = '';\n      let memoContent = '';\n      let relatedSentenceIds: string[] = [];\n      let relatedSentenceContents: string[] = [];\n      \n      for (const sentenceId of selectedIds) {\n        const isHighlighted = highlightedSentences.has(sentenceId);\n        const currentMemoContent = memos[sentenceId] || null;\n        \n        highlightStates.push(isHighlighted);\n        highlightColors.push(isHighlighted ? 'yellow' : null);\n        memoContents.push(currentMemoContent);\n        \n        // 메모가 있는 문장을 찾으면 관련 정보 수집\n        if (currentMemoContent && currentMemoContent.trim() !== '') {\n          hasMemo = true;\n          memoSentenceId = sentenceId;\n          memoContent = currentMemoContent;\n          relatedSentenceIds = selectedIds; // 선택된 모든 문장이 연관됨\n          relatedSentenceContents = selectedTexts;\n        }\n      }\n\n      // 일반 저장고 저장 (기존 로직)\n      await sentenceApi.saveSentencesToVault({\n        sentences: selectedTexts,\n        source_message_id: `${threadType}_${personaId}`,\n        source_conversation_id: selectedThread.id,\n        source_thread_id: selectedThread.id,\n        source_thread_type: threadType,\n        source_sentence_ids: selectedIds,\n        tags: [threadType, personaId],\n        highlight_states: highlightStates,\n        highlight_colors: highlightColors,\n        memo_contents: memoContents\n      });\n      \n      // 메모가 있는 경우 메모 저장고에도 별도 저장 (연관된 문장들과 함께)\n      if (hasMemo) {\n        console.log('=== 메모 저장고 저장 ===');\n        console.log('메모 문장 ID:', memoSentenceId);\n        console.log('메모 내용:', memoContent);\n        console.log('연관된 문장들:', relatedSentenceContents);\n        \n        try {\n          await sentenceApi.saveMemoToVault({\n            memo_content: memoContent,\n            sentence_content: relatedSentenceContents.length > 1 \n              ? relatedSentenceContents.map(s => `\"${s}\"`).join(', ')  // 여러 문장인 경우\n              : relatedSentenceContents[0] || '', // 단일 문장인 경우\n            source_message_id: `${threadType}_${personaId}`,\n            source_conversation_id: selectedThread.id,\n            source_thread_id: selectedThread.id,\n            source_thread_type: threadType,\n            source_sentence_id: memoSentenceId,\n            tags: [threadType, personaId],\n            metadata: {\n              related_sentence_ids: relatedSentenceIds,\n              related_sentence_contents: relatedSentenceContents,\n              memo_type: relatedSentenceContents.length > 1 ? 'multi_sentence' : 'single_sentence'\n            }\n          });\n          console.log('메모 저장고 저장 완료');\n        } catch (error) {\n          console.error('메모 저장고 저장 실패:', error);\n        }\n      }\n      \n      // 백엔드에 하이라이트도 저장\n      for (const sentenceId of selectedIds) {\n        await sentenceApi.createHighlight({\n          sentence_id: sentenceId,\n          thread_id: selectedThread.id,\n          thread_type: threadType\n        });\n      }\n      \n      // 성공 시 로컬 상태 업데이트\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      if (hasMemo) {\n        showCopyToast('저장고에 저장되었습니다 (메모와 연관 문장들 포함)');\n      } else {\n        showCopyToast('저장고에 저장되었습니다 (하이라이트 정보 포함)');\n      }\n    } catch (error) {\n      console.error('저장고 저장 실패:', error);\n      showCopyToast('저장고 저장에 실패했습니다');\n    }\n  };\n\n  const handleAddMemo = async (selectedIds: string[], selectedTexts: string[]) => {\n    if (selectedIds.length === 0) return;\n\n    try {\n      // 백엔드에 모든 선택된 문장의 하이라이트 저장\n      if (selectedThread?.id) {\n        for (const sentenceId of selectedIds) {\n          await sentenceApi.createHighlight({\n            sentence_id: sentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType\n          });\n        }\n      }\n      \n      // 마지막 문장 ID 찾기 (가장 큰 인덱스)\n      const sortedIds = selectedIds.sort();\n      const lastSentenceId = sortedIds[sortedIds.length - 1];\n      \n      // 마지막 문장에만 빈 메모 추가\n      const newMemos: Record<string, string> = {\n        [lastSentenceId]: ''\n      };\n      \n      // 메모에 연관된 문장들 정보 저장 (메타데이터로)\n      const relatedSentenceIds = selectedIds;\n      const relatedSentenceTexts = selectedTexts;\n      \n      console.log('=== 메모 생성 정보 ===');\n      console.log('마지막 문장 ID:', lastSentenceId);\n      console.log('연관된 문장 ID들:', relatedSentenceIds);\n      console.log('연관된 문장 텍스트들:', relatedSentenceTexts);\n      \n      // 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\n      if (selectedThread?.id) {\n        try {\n          await sentenceApi.createOrUpdateMemo({\n            sentence_id: lastSentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType,\n            content: '', // 빈 메모로 시작\n            related_sentence_ids: relatedSentenceIds,\n            related_sentence_contents: relatedSentenceTexts,\n            sentence_content: selectedTexts[selectedTexts.length - 1], // 마지막 문장 내용\n            source_message_id: `${threadType}_memo_${Date.now()}`\n          } as any);\n        } catch (error) {\n          console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):', error);\n        }\n      }\n      \n      // 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\n      setMemos(prev => ({ ...prev, ...newMemos }));\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      // 선택된 문장이 여러 개인 경우 안내 메시지\n      if (selectedIds.length > 1) {\n        showCopyToast(`메모가 마지막 문장에 생성되었습니다 (연관 문장: ${selectedIds.length}개)`);\n      } else {\n        showCopyToast('메모와 하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('메모/하이라이트 추가 실패:', error);\n      showCopyToast('메모/하이라이트 추가에 실패했습니다');\n    }\n  };\n\n  const handleToggleHighlight = async (selectedIds: string[]) => {\n    if (!selectedIds.length || !selectedThread?.id) return;\n\n    try {\n      const currentlyHighlighted = selectedIds.filter(id => highlightedSentences.has(id));\n      \n      if (currentlyHighlighted.length > 0) {\n        // 하이라이트 제거\n        setHighlightedSentences(prev => {\n          const newSet = new Set(prev);\n          selectedIds.forEach(id => newSet.delete(id));\n          return newSet;\n        });\n        \n        // 백엔드에서 하이라이트 삭제\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.deleteHighlight(sentenceId);\n          } catch (error) {\n            console.warn('백엔드 하이라이트 삭제 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 제거되었습니다');\n      } else {\n        // 하이라이트 추가\n        setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n        \n        // 백엔드에 하이라이트 저장\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.createHighlight({\n              sentence_id: sentenceId,\n              thread_id: selectedThread.id,\n              thread_type: threadType\n            });\n          } catch (error) {\n            console.warn('백엔드 하이라이트 저장 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('하이라이트 토글 실패:', error);\n      showCopyToast('하이라이트 처리에 실패했습니다');\n    }\n  };\n\n  const handleMenuAction = async (\n    action: 'sendToInput' | 'saveToVault' | 'addMemo' | 'highlight' | 'copy',\n    selectedIds: string[],\n    selectedTexts: string[],\n    messageInputRef?: React.RefObject<any>\n  ) => {\n    switch (action) {\n      case 'sendToInput':\n        if (messageInputRef?.current && selectedTexts.length > 0) {\n          const formattedText = selectedTexts.map(text => `\"${text}\"`).join(', ');\n          messageInputRef.current.insertText(formattedText);\n          showCopyToast('선택한 문장이 입력창에 추가되었습니다');\n        }\n        break;\n      \n      case 'saveToVault':\n        await handleSaveToVault(selectedIds, selectedTexts);\n        break;\n      \n      case 'addMemo':\n        await handleAddMemo(selectedIds, selectedTexts);\n        break;\n      \n      case 'highlight':\n        await handleToggleHighlight(selectedIds);\n        break;\n      \n      case 'copy':\n        if (selectedTexts.length > 0) {\n          await copyTextToClipboard(selectedTexts.join(' '), '선택된 문장이 복사되었습니다');\n        }\n        break;\n    }\n\n    // 모든 선택 해제\n    setSelectedSentences(new Set());\n  };\n\n  return {\n    selectedSentences,\n    setSelectedSentences,\n    handleMenuAction,\n    handleSaveToVault,\n    handleAddMemo,\n    handleToggleHighlight\n  };\n}; "],"mappings":";AAAA,SAASA,QAAQ,QAAQ,OAAO;AAChC,SAASC,WAAW,QAAQ,gCAAgC;AAC5D,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,YAAY,QAAQ,gBAAgB;AAa7C,OAAO,MAAMC,eAAe,GAAGA,CAAC;EAC9BC,SAAS;EACTC,UAAU;EACVC,cAAc;EACdC,KAAK;EACLC,oBAAoB;EACpBC,QAAQ;EACRC;AACoB,CAAC,KAAK;EAAAC,EAAA;EAC1B,MAAM;IAAEC;EAAc,CAAC,GAAGX,QAAQ,CAAC,CAAC;EACpC,MAAM;IAAEY;EAAoB,CAAC,GAAGX,YAAY,CAAC,CAAC;EAC9C,MAAM,CAACY,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGhB,QAAQ,CAAc,IAAIiB,GAAG,CAAC,CAAC,CAAC;EAElF,MAAMC,iBAAiB,GAAG,MAAAA,CAAOC,WAAqB,EAAEC,aAAuB,KAAK;IAClF,IAAI;MACF,IAAI,CAACA,aAAa,CAACC,MAAM,EAAE;QACzBR,aAAa,CAAC,gBAAgB,CAAC;QAC/B;MACF;MAEA,IAAI,EAACN,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEe,EAAE,GAAE;QACvBT,aAAa,CAAC,iBAAiB,CAAC;QAChC;MACF;;MAEA;MACA,MAAMU,eAA0B,GAAG,EAAE;MACrC,MAAMC,eAAkC,GAAG,EAAE;MAC7C,MAAMC,YAA+B,GAAG,EAAE;;MAE1C;MACA,IAAIC,OAAO,GAAG,KAAK;MACnB,IAAIC,cAAc,GAAG,EAAE;MACvB,IAAIC,WAAW,GAAG,EAAE;MACpB,IAAIC,kBAA4B,GAAG,EAAE;MACrC,IAAIC,uBAAiC,GAAG,EAAE;MAE1C,KAAK,MAAMC,UAAU,IAAIZ,WAAW,EAAE;QACpC,MAAMa,aAAa,GAAGvB,oBAAoB,CAACwB,GAAG,CAACF,UAAU,CAAC;QAC1D,MAAMG,kBAAkB,GAAG1B,KAAK,CAACuB,UAAU,CAAC,IAAI,IAAI;QAEpDR,eAAe,CAACY,IAAI,CAACH,aAAa,CAAC;QACnCR,eAAe,CAACW,IAAI,CAACH,aAAa,GAAG,QAAQ,GAAG,IAAI,CAAC;QACrDP,YAAY,CAACU,IAAI,CAACD,kBAAkB,CAAC;;QAErC;QACA,IAAIA,kBAAkB,IAAIA,kBAAkB,CAACE,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;UAC1DV,OAAO,GAAG,IAAI;UACdC,cAAc,GAAGI,UAAU;UAC3BH,WAAW,GAAGM,kBAAkB;UAChCL,kBAAkB,GAAGV,WAAW,CAAC,CAAC;UAClCW,uBAAuB,GAAGV,aAAa;QACzC;MACF;;MAEA;MACA,MAAMnB,WAAW,CAACoC,oBAAoB,CAAC;QACrCC,SAAS,EAAElB,aAAa;QACxBmB,iBAAiB,EAAE,GAAGjC,UAAU,IAAID,SAAS,EAAE;QAC/CmC,sBAAsB,EAAEjC,cAAc,CAACe,EAAE;QACzCmB,gBAAgB,EAAElC,cAAc,CAACe,EAAE;QACnCoB,kBAAkB,EAAEpC,UAAU;QAC9BqC,mBAAmB,EAAExB,WAAW;QAChCyB,IAAI,EAAE,CAACtC,UAAU,EAAED,SAAS,CAAC;QAC7BwC,gBAAgB,EAAEtB,eAAe;QACjCuB,gBAAgB,EAAEtB,eAAe;QACjCuB,aAAa,EAAEtB;MACjB,CAAC,CAAC;;MAEF;MACA,IAAIC,OAAO,EAAE;QACXsB,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAAC;QAChCD,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEtB,cAAc,CAAC;QACxCqB,OAAO,CAACC,GAAG,CAAC,QAAQ,EAAErB,WAAW,CAAC;QAClCoB,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEnB,uBAAuB,CAAC;QAEhD,IAAI;UACF,MAAM7B,WAAW,CAACiD,eAAe,CAAC;YAChCC,YAAY,EAAEvB,WAAW;YACzBwB,gBAAgB,EAAEtB,uBAAuB,CAACT,MAAM,GAAG,CAAC,GAChDS,uBAAuB,CAACuB,GAAG,CAACC,CAAC,IAAI,IAAIA,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAE;YAAA,EACvDzB,uBAAuB,CAAC,CAAC,CAAC,IAAI,EAAE;YAAE;YACtCS,iBAAiB,EAAE,GAAGjC,UAAU,IAAID,SAAS,EAAE;YAC/CmC,sBAAsB,EAAEjC,cAAc,CAACe,EAAE;YACzCmB,gBAAgB,EAAElC,cAAc,CAACe,EAAE;YACnCoB,kBAAkB,EAAEpC,UAAU;YAC9BkD,kBAAkB,EAAE7B,cAAc;YAClCiB,IAAI,EAAE,CAACtC,UAAU,EAAED,SAAS,CAAC;YAC7BoD,QAAQ,EAAE;cACRC,oBAAoB,EAAE7B,kBAAkB;cACxC8B,yBAAyB,EAAE7B,uBAAuB;cAClD8B,SAAS,EAAE9B,uBAAuB,CAACT,MAAM,GAAG,CAAC,GAAG,gBAAgB,GAAG;YACrE;UACF,CAAC,CAAC;UACF2B,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;QAC7B,CAAC,CAAC,OAAOY,KAAK,EAAE;UACdb,OAAO,CAACa,KAAK,CAAC,eAAe,EAAEA,KAAK,CAAC;QACvC;MACF;;MAEA;MACA,KAAK,MAAM9B,UAAU,IAAIZ,WAAW,EAAE;QACpC,MAAMlB,WAAW,CAAC6D,eAAe,CAAC;UAChCC,WAAW,EAAEhC,UAAU;UACvBiC,SAAS,EAAEzD,cAAc,CAACe,EAAE;UAC5B2C,WAAW,EAAE3D;QACf,CAAC,CAAC;MACJ;;MAEA;MACAK,uBAAuB,CAACuD,IAAI,IAAI,IAAIjD,GAAG,CAAC,CAAC,GAAGkD,KAAK,CAACC,IAAI,CAACF,IAAI,CAAC,EAAE,GAAG/C,WAAW,CAAC,CAAC,CAAC;MAE/E,IAAIO,OAAO,EAAE;QACXb,aAAa,CAAC,8BAA8B,CAAC;MAC/C,CAAC,MAAM;QACLA,aAAa,CAAC,4BAA4B,CAAC;MAC7C;IACF,CAAC,CAAC,OAAOgD,KAAK,EAAE;MACdb,OAAO,CAACa,KAAK,CAAC,YAAY,EAAEA,KAAK,CAAC;MAClChD,aAAa,CAAC,gBAAgB,CAAC;IACjC;EACF,CAAC;EAED,MAAMwD,aAAa,GAAG,MAAAA,CAAOlD,WAAqB,EAAEC,aAAuB,KAAK;IAC9E,IAAID,WAAW,CAACE,MAAM,KAAK,CAAC,EAAE;IAE9B,IAAI;MACF;MACA,IAAId,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEe,EAAE,EAAE;QACtB,KAAK,MAAMS,UAAU,IAAIZ,WAAW,EAAE;UACpC,MAAMlB,WAAW,CAAC6D,eAAe,CAAC;YAChCC,WAAW,EAAEhC,UAAU;YACvBiC,SAAS,EAAEzD,cAAc,CAACe,EAAE;YAC5B2C,WAAW,EAAE3D;UACf,CAAC,CAAC;QACJ;MACF;;MAEA;MACA,MAAMgE,SAAS,GAAGnD,WAAW,CAACoD,IAAI,CAAC,CAAC;MACpC,MAAMC,cAAc,GAAGF,SAAS,CAACA,SAAS,CAACjD,MAAM,GAAG,CAAC,CAAC;;MAEtD;MACA,MAAMoD,QAAgC,GAAG;QACvC,CAACD,cAAc,GAAG;MACpB,CAAC;;MAED;MACA,MAAM3C,kBAAkB,GAAGV,WAAW;MACtC,MAAMuD,oBAAoB,GAAGtD,aAAa;MAE1C4B,OAAO,CAACC,GAAG,CAAC,kBAAkB,CAAC;MAC/BD,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEuB,cAAc,CAAC;MACzCxB,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEpB,kBAAkB,CAAC;MAC9CmB,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEyB,oBAAoB,CAAC;;MAEjD;MACA,IAAInE,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEe,EAAE,EAAE;QACtB,IAAI;UACF,MAAMrB,WAAW,CAAC0E,kBAAkB,CAAC;YACnCZ,WAAW,EAAES,cAAc;YAC3BR,SAAS,EAAEzD,cAAc,CAACe,EAAE;YAC5B2C,WAAW,EAAE3D,UAAU;YACvBsE,OAAO,EAAE,EAAE;YAAE;YACblB,oBAAoB,EAAE7B,kBAAkB;YACxC8B,yBAAyB,EAAEe,oBAAoB;YAC/CtB,gBAAgB,EAAEhC,aAAa,CAACA,aAAa,CAACC,MAAM,GAAG,CAAC,CAAC;YAAE;YAC3DkB,iBAAiB,EAAE,GAAGjC,UAAU,SAASuE,IAAI,CAACC,GAAG,CAAC,CAAC;UACrD,CAAQ,CAAC;QACX,CAAC,CAAC,OAAOjB,KAAK,EAAE;UACdb,OAAO,CAAC+B,IAAI,CAAC,2BAA2B,EAAElB,KAAK,CAAC;QAClD;MACF;;MAEA;MACAnD,QAAQ,CAACwD,IAAI,KAAK;QAAE,GAAGA,IAAI;QAAE,GAAGO;MAAS,CAAC,CAAC,CAAC;MAC5C9D,uBAAuB,CAACuD,IAAI,IAAI,IAAIjD,GAAG,CAAC,CAAC,GAAGkD,KAAK,CAACC,IAAI,CAACF,IAAI,CAAC,EAAE,GAAG/C,WAAW,CAAC,CAAC,CAAC;;MAE/E;MACA,IAAIA,WAAW,CAACE,MAAM,GAAG,CAAC,EAAE;QAC1BR,aAAa,CAAC,+BAA+BM,WAAW,CAACE,MAAM,IAAI,CAAC;MACtE,CAAC,MAAM;QACLR,aAAa,CAAC,oBAAoB,CAAC;MACrC;IACF,CAAC,CAAC,OAAOgD,KAAK,EAAE;MACdb,OAAO,CAACa,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAAC;MACvChD,aAAa,CAAC,qBAAqB,CAAC;IACtC;EACF,CAAC;EAED,MAAMmE,qBAAqB,GAAG,MAAO7D,WAAqB,IAAK;IAC7D,IAAI,CAACA,WAAW,CAACE,MAAM,IAAI,EAACd,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEe,EAAE,GAAE;IAEhD,IAAI;MACF,MAAM2D,oBAAoB,GAAG9D,WAAW,CAAC+D,MAAM,CAAC5D,EAAE,IAAIb,oBAAoB,CAACwB,GAAG,CAACX,EAAE,CAAC,CAAC;MAEnF,IAAI2D,oBAAoB,CAAC5D,MAAM,GAAG,CAAC,EAAE;QACnC;QACAV,uBAAuB,CAACuD,IAAI,IAAI;UAC9B,MAAMiB,MAAM,GAAG,IAAIlE,GAAG,CAACiD,IAAI,CAAC;UAC5B/C,WAAW,CAACiE,OAAO,CAAC9D,EAAE,IAAI6D,MAAM,CAACE,MAAM,CAAC/D,EAAE,CAAC,CAAC;UAC5C,OAAO6D,MAAM;QACf,CAAC,CAAC;;QAEF;QACA,KAAK,MAAMpD,UAAU,IAAIZ,WAAW,EAAE;UACpC,IAAI;YACF,MAAMlB,WAAW,CAACqF,eAAe,CAACvD,UAAU,CAAC;UAC/C,CAAC,CAAC,OAAO8B,KAAK,EAAE;YACdb,OAAO,CAAC+B,IAAI,CAAC,kBAAkB,EAAElB,KAAK,CAAC;UACzC;QACF;QAEAhD,aAAa,CAAC,gBAAgB,CAAC;MACjC,CAAC,MAAM;QACL;QACAF,uBAAuB,CAACuD,IAAI,IAAI,IAAIjD,GAAG,CAAC,CAAC,GAAGkD,KAAK,CAACC,IAAI,CAACF,IAAI,CAAC,EAAE,GAAG/C,WAAW,CAAC,CAAC,CAAC;;QAE/E;QACA,KAAK,MAAMY,UAAU,IAAIZ,WAAW,EAAE;UACpC,IAAI;YACF,MAAMlB,WAAW,CAAC6D,eAAe,CAAC;cAChCC,WAAW,EAAEhC,UAAU;cACvBiC,SAAS,EAAEzD,cAAc,CAACe,EAAE;cAC5B2C,WAAW,EAAE3D;YACf,CAAC,CAAC;UACJ,CAAC,CAAC,OAAOuD,KAAK,EAAE;YACdb,OAAO,CAAC+B,IAAI,CAAC,kBAAkB,EAAElB,KAAK,CAAC;UACzC;QACF;QAEAhD,aAAa,CAAC,gBAAgB,CAAC;MACjC;IACF,CAAC,CAAC,OAAOgD,KAAK,EAAE;MACdb,OAAO,CAACa,KAAK,CAAC,cAAc,EAAEA,KAAK,CAAC;MACpChD,aAAa,CAAC,kBAAkB,CAAC;IACnC;EACF,CAAC;EAED,MAAM0E,gBAAgB,GAAG,MAAAA,CACvBC,MAAwE,EACxErE,WAAqB,EACrBC,aAAuB,EACvBqE,eAAsC,KACnC;IACH,QAAQD,MAAM;MACZ,KAAK,aAAa;QAChB,IAAIC,eAAe,aAAfA,eAAe,eAAfA,eAAe,CAAEC,OAAO,IAAItE,aAAa,CAACC,MAAM,GAAG,CAAC,EAAE;UACxD,MAAMsE,aAAa,GAAGvE,aAAa,CAACiC,GAAG,CAACuC,IAAI,IAAI,IAAIA,IAAI,GAAG,CAAC,CAACrC,IAAI,CAAC,IAAI,CAAC;UACvEkC,eAAe,CAACC,OAAO,CAACG,UAAU,CAACF,aAAa,CAAC;UACjD9E,aAAa,CAAC,sBAAsB,CAAC;QACvC;QACA;MAEF,KAAK,aAAa;QAChB,MAAMK,iBAAiB,CAACC,WAAW,EAAEC,aAAa,CAAC;QACnD;MAEF,KAAK,SAAS;QACZ,MAAMiD,aAAa,CAAClD,WAAW,EAAEC,aAAa,CAAC;QAC/C;MAEF,KAAK,WAAW;QACd,MAAM4D,qBAAqB,CAAC7D,WAAW,CAAC;QACxC;MAEF,KAAK,MAAM;QACT,IAAIC,aAAa,CAACC,MAAM,GAAG,CAAC,EAAE;UAC5B,MAAMP,mBAAmB,CAACM,aAAa,CAACmC,IAAI,CAAC,GAAG,CAAC,EAAE,iBAAiB,CAAC;QACvE;QACA;IACJ;;IAEA;IACAvC,oBAAoB,CAAC,IAAIC,GAAG,CAAC,CAAC,CAAC;EACjC,CAAC;EAED,OAAO;IACLF,iBAAiB;IACjBC,oBAAoB;IACpBuE,gBAAgB;IAChBrE,iBAAiB;IACjBmD,aAAa;IACbW;EACF,CAAC;AACH,CAAC;AAACpE,EAAA,CA7RWR,eAAe;EAAA,QASAF,QAAQ,EACFC,YAAY;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}