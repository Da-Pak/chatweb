{"ast":null,"code":"import _objectSpread from\"C:/Users/sungh/Desktop/chat_work_ver2/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useState,useEffect}from'react';import{sentenceApi}from'../../training/api/sentenceApi';export const useSentenceData=threadId=>{const[memos,setMemos]=useState({});const[highlightedSentences,setHighlightedSentences]=useState(new Set());const[isLoading,setIsLoading]=useState(false);const[error,setError]=useState(null);// 스레드별 메모/하이라이트 데이터 로딩\nuseEffect(()=>{if(threadId){loadThreadSentenceData();}},[threadId]);const loadThreadSentenceData=async()=>{if(!threadId)return;console.log('=== 스레드 문장 데이터 로딩 시작 ===');console.log('대상 스레드 ID:',threadId);setIsLoading(true);setError(null);try{var _data$highlights;const data=await sentenceApi.getThreadSentenceData(threadId);console.log('로딩된 데이터:',{memo_count:Object.keys(data.memos||{}).length,highlight_count:((_data$highlights=data.highlights)===null||_data$highlights===void 0?void 0:_data$highlights.length)||0,memos:data.memos,highlights:data.highlights});setMemos(data.memos||{});setHighlightedSentences(new Set(data.highlights||[]));console.log('스레드 문장 데이터 로딩 완료');}catch(error){console.error('스레드 문장 데이터 로딩 실패:',error);setError(error instanceof Error?error.message:'데이터 로딩에 실패했습니다');// 실패 시 빈 상태로 초기화\nsetMemos({});setHighlightedSentences(new Set());}finally{setIsLoading(false);}};const handleMemoChange=async(sentenceId,memo,threadId,threadType)=>{console.log('=== 메모 변경 처리 시작 ===');console.log('문장 ID:',sentenceId);console.log('메모 내용:',memo.substring(0,50)+(memo.length>50?'...':''));console.log('스레드 ID:',threadId);console.log('스레드 타입:',threadType);try{// 로컬 상태에서 메모 즉시 업데이트 (UI 반응성)\nsetMemos(prev=>_objectSpread(_objectSpread({},prev),{},{[sentenceId]:memo}));// 백엔드 API 호출\nconst response=await sentenceApi.createOrUpdateMemo({sentence_id:sentenceId,thread_id:threadId,thread_type:threadType,content:memo});console.log('메모 저장 API 응답:',response);console.log('메모 변경 처리 완료');return response;}catch(error){console.error('메모 저장 실패:',error);// 실패 시 원래 상태로 되돌리기\nsetMemos(prev=>{const newMemos=_objectSpread({},prev);if(memo.trim()===''){delete newMemos[sentenceId];}else{// 이전 상태를 복원하기 어려우므로 다시 로딩\nloadThreadSentenceData();}return newMemos;});throw error;}};const handleDeleteMemo=async sentenceId=>{console.log('=== 메모 삭제 처리 시작 ===');console.log('문장 ID:',sentenceId);try{// 로컬 상태에서 메모 즉시 제거 (UI 반응성)\nconst previousMemo=memos[sentenceId];setMemos(prev=>{const newMemos=_objectSpread({},prev);delete newMemos[sentenceId];return newMemos;});// 백엔드 API 호출\nconst response=await sentenceApi.deleteMemo(sentenceId);console.log('메모 삭제 API 응답:',response);console.log('메모 삭제 처리 완료');return response;}catch(error){console.error('메모 삭제 실패:',error);// 실패 시 원래 상태로 되돌리기\nif(memos[sentenceId]!==undefined){setMemos(prev=>_objectSpread(_objectSpread({},prev),{},{[sentenceId]:memos[sentenceId]}));}throw error;}};const handleToggleHighlight=async(sentenceId,threadId,threadType)=>{console.log('=== 하이라이트 토글 처리 시작 ===');console.log('문장 ID:',sentenceId);console.log('현재 하이라이트 상태:',highlightedSentences.has(sentenceId));const isCurrentlyHighlighted=highlightedSentences.has(sentenceId);try{// 로컬 상태에서 하이라이트 즉시 토글 (UI 반응성)\nsetHighlightedSentences(prev=>{const newSet=new Set(prev);if(isCurrentlyHighlighted){newSet.delete(sentenceId);}else{newSet.add(sentenceId);}return newSet;});// 백엔드 API 호출\nlet response;if(isCurrentlyHighlighted){response=await sentenceApi.deleteHighlight(sentenceId);}else{// threadId와 threadType이 없으면 빈 문자열로 처리\nresponse=await sentenceApi.createHighlight({sentence_id:sentenceId,thread_id:threadId||'',thread_type:threadType||''});}console.log('하이라이트 토글 API 응답:',response);console.log('하이라이트 토글 처리 완료');return response;}catch(error){console.error('하이라이트 토글 실패:',error);// 실패 시 원래 상태로 되돌리기\nsetHighlightedSentences(prev=>{const newSet=new Set(prev);if(isCurrentlyHighlighted){newSet.add(sentenceId);}else{newSet.delete(sentenceId);}return newSet;});throw error;}};return{memos,highlightedSentences,isLoading,error,loadThreadSentenceData,handleMemoChange,handleDeleteMemo,handleToggleHighlight,setMemos,setHighlightedSentences};};","map":{"version":3,"names":["useState","useEffect","sentenceApi","useSentenceData","threadId","memos","setMemos","highlightedSentences","setHighlightedSentences","Set","isLoading","setIsLoading","error","setError","loadThreadSentenceData","console","log","_data$highlights","data","getThreadSentenceData","memo_count","Object","keys","length","highlight_count","highlights","Error","message","handleMemoChange","sentenceId","memo","threadType","substring","prev","_objectSpread","response","createOrUpdateMemo","sentence_id","thread_id","thread_type","content","newMemos","trim","handleDeleteMemo","previousMemo","deleteMemo","undefined","handleToggleHighlight","has","isCurrentlyHighlighted","newSet","delete","add","deleteHighlight","createHighlight"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/shared/hooks/useSentenceData.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { sentenceApi } from '../../training/api/sentenceApi';\r\n\r\nexport const useSentenceData = (threadId?: string) => {\r\n  const [memos, setMemos] = useState<Record<string, string>>({});\r\n  const [highlightedSentences, setHighlightedSentences] = useState<Set<string>>(new Set());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // 스레드별 메모/하이라이트 데이터 로딩\r\n  useEffect(() => {\r\n    if (threadId) {\r\n      loadThreadSentenceData();\r\n    }\r\n  }, [threadId]);\r\n\r\n  const loadThreadSentenceData = async () => {\r\n    if (!threadId) return;\r\n    \r\n    console.log('=== 스레드 문장 데이터 로딩 시작 ===');\r\n    console.log('대상 스레드 ID:', threadId);\r\n    \r\n    setIsLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const data = await sentenceApi.getThreadSentenceData(threadId);\r\n      \r\n      console.log('로딩된 데이터:', {\r\n        memo_count: Object.keys(data.memos || {}).length,\r\n        highlight_count: data.highlights?.length || 0,\r\n        memos: data.memos,\r\n        highlights: data.highlights\r\n      });\r\n      \r\n      setMemos(data.memos || {});\r\n      setHighlightedSentences(new Set(data.highlights || []));\r\n      \r\n      console.log('스레드 문장 데이터 로딩 완료');\r\n    } catch (error) {\r\n      console.error('스레드 문장 데이터 로딩 실패:', error);\r\n      setError(error instanceof Error ? error.message : '데이터 로딩에 실패했습니다');\r\n      \r\n      // 실패 시 빈 상태로 초기화\r\n      setMemos({});\r\n      setHighlightedSentences(new Set());\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleMemoChange = async (\r\n    sentenceId: string, \r\n    memo: string, \r\n    threadId?: string, \r\n    threadType?: string\r\n  ) => {\r\n    console.log('=== 메모 변경 처리 시작 ===');\r\n    console.log('문장 ID:', sentenceId);\r\n    console.log('메모 내용:', memo.substring(0, 50) + (memo.length > 50 ? '...' : ''));\r\n    console.log('스레드 ID:', threadId);\r\n    console.log('스레드 타입:', threadType);\r\n    \r\n    try {\r\n      // 로컬 상태에서 메모 즉시 업데이트 (UI 반응성)\r\n      setMemos(prev => ({\r\n        ...prev,\r\n        [sentenceId]: memo\r\n      }));\r\n      \r\n      // 백엔드 API 호출\r\n      const response = await sentenceApi.createOrUpdateMemo({\r\n        sentence_id: sentenceId,\r\n        thread_id: threadId,\r\n        thread_type: threadType,\r\n        content: memo\r\n      });\r\n      \r\n      console.log('메모 저장 API 응답:', response);\r\n      console.log('메모 변경 처리 완료');\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('메모 저장 실패:', error);\r\n      \r\n      // 실패 시 원래 상태로 되돌리기\r\n      setMemos(prev => {\r\n        const newMemos = { ...prev };\r\n        if (memo.trim() === '') {\r\n          delete newMemos[sentenceId];\r\n        } else {\r\n          // 이전 상태를 복원하기 어려우므로 다시 로딩\r\n          loadThreadSentenceData();\r\n        }\r\n        return newMemos;\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const handleDeleteMemo = async (sentenceId: string) => {\r\n    console.log('=== 메모 삭제 처리 시작 ===');\r\n    console.log('문장 ID:', sentenceId);\r\n    \r\n    try {\r\n      // 로컬 상태에서 메모 즉시 제거 (UI 반응성)\r\n      const previousMemo = memos[sentenceId];\r\n      setMemos(prev => {\r\n        const newMemos = { ...prev };\r\n        delete newMemos[sentenceId];\r\n        return newMemos;\r\n      });\r\n      \r\n      // 백엔드 API 호출\r\n      const response = await sentenceApi.deleteMemo(sentenceId);\r\n      \r\n      console.log('메모 삭제 API 응답:', response);\r\n      console.log('메모 삭제 처리 완료');\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('메모 삭제 실패:', error);\r\n      \r\n      // 실패 시 원래 상태로 되돌리기\r\n      if (memos[sentenceId] !== undefined) {\r\n        setMemos(prev => ({\r\n          ...prev,\r\n          [sentenceId]: memos[sentenceId]\r\n        }));\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const handleToggleHighlight = async (\r\n    sentenceId: string, \r\n    threadId?: string, \r\n    threadType?: string\r\n  ) => {\r\n    console.log('=== 하이라이트 토글 처리 시작 ===');\r\n    console.log('문장 ID:', sentenceId);\r\n    console.log('현재 하이라이트 상태:', highlightedSentences.has(sentenceId));\r\n    \r\n    const isCurrentlyHighlighted = highlightedSentences.has(sentenceId);\r\n    \r\n    try {\r\n      // 로컬 상태에서 하이라이트 즉시 토글 (UI 반응성)\r\n      setHighlightedSentences(prev => {\r\n        const newSet = new Set(prev);\r\n        if (isCurrentlyHighlighted) {\r\n          newSet.delete(sentenceId);\r\n        } else {\r\n          newSet.add(sentenceId);\r\n        }\r\n        return newSet;\r\n      });\r\n      \r\n      // 백엔드 API 호출\r\n      let response;\r\n      if (isCurrentlyHighlighted) {\r\n        response = await sentenceApi.deleteHighlight(sentenceId);\r\n      } else {\r\n        // threadId와 threadType이 없으면 빈 문자열로 처리\r\n        response = await sentenceApi.createHighlight({\r\n          sentence_id: sentenceId,\r\n          thread_id: threadId || '',\r\n          thread_type: threadType || ''\r\n        });\r\n      }\r\n      \r\n      console.log('하이라이트 토글 API 응답:', response);\r\n      console.log('하이라이트 토글 처리 완료');\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('하이라이트 토글 실패:', error);\r\n      \r\n      // 실패 시 원래 상태로 되돌리기\r\n      setHighlightedSentences(prev => {\r\n        const newSet = new Set(prev);\r\n        if (isCurrentlyHighlighted) {\r\n          newSet.add(sentenceId);\r\n        } else {\r\n          newSet.delete(sentenceId);\r\n        }\r\n        return newSet;\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  };\r\n\r\n  return {\r\n    memos,\r\n    highlightedSentences,\r\n    isLoading,\r\n    error,\r\n    loadThreadSentenceData,\r\n    handleMemoChange,\r\n    handleDeleteMemo,\r\n    handleToggleHighlight,\r\n    setMemos,\r\n    setHighlightedSentences\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}