{"ast":null,"code":"import{apiGet,apiPost,apiDelete,VaultManager}from'../../shared/utils/apiUtils';// 메모 저장고 관련 타입들\n// 저장고 매니저 인스턴스들\nconst sentenceVaultManager=new VaultManager('/vault/sentences');const memoVaultManager=new VaultManager('/vault/memos');class SentenceApi{// === 문장 저장고 관련 API (VaultManager 사용) ===\nasync saveSentencesToVault(request){console.log('=== 저장고 저장 시작 (통합 API 사용) ===');console.log('요청 데이터:',JSON.stringify(request,null,2));try{const response=await sentenceVaultManager.create(request);if(response.error){throw new Error(response.error);}console.log('성공 응답:',response.data);console.log('=== 저장고 저장 완료 ===');return response.data;}catch(error){console.error('저장고 저장 오류:',error);throw error;}}async getVaultSentences(){const response=await sentenceVaultManager.getAll();if(response.error){throw new Error(response.error);}return response.data||[];}async deleteVaultSentence(sentenceId){const response=await sentenceVaultManager.delete(sentenceId);if(response.error){throw new Error(response.error);}return response.data||{success:false,message:'삭제 실패'};}async updateVaultSentence(sentenceId,request){const response=await sentenceVaultManager.update(sentenceId,request);if(response.error){throw new Error(response.error);}return response.data;}async restoreVaultSentence(vaultSentenceId,request){const response=await apiPost(\"/vault/sentences/\".concat(vaultSentenceId,\"/restore\"),request);if(response.error){throw new Error(response.error);}return response.data;}// === 메모 관련 API (통합) ===\nasync createOrUpdateMemo(request){const response=await apiPost('/memos',request);if(response.error){throw new Error(response.error);}return response.data;}async getMemo(sentenceId){const response=await apiGet(\"/memos/\".concat(sentenceId));return response.data||null;}async deleteMemo(sentenceId){const response=await apiDelete(\"/memos/\".concat(sentenceId));if(response.data){return response.data;}// 404는 이미 삭제된 것으로 간주\nreturn{success:true,message:'메모가 이미 삭제되었습니다'};}async getAllMemos(){const response=await apiGet('/memos');return response.data||{};}// === 하이라이트 관련 API (통합) ===\nasync createHighlight(request){const response=await apiPost('/highlights',request);if(response.error){throw new Error(response.error);}return response.data;}async deleteHighlight(sentenceId){const response=await apiDelete(\"/highlights/\".concat(sentenceId));if(response.data){return response.data;}// 404는 이미 삭제된 것으로 간주\nreturn{success:true,message:'하이라이트가 이미 삭제되었습니다'};}async getAllHighlights(){const response=await apiGet('/highlights');return response.data||{};}async getThreadHighlights(threadId){var _response$data;const response=await apiGet(\"/highlights/thread/\".concat(threadId));return((_response$data=response.data)===null||_response$data===void 0?void 0:_response$data.highlights)||[];}// === 스레드 관련 API ===\nasync getThreadSentenceData(threadId){const response=await apiGet(\"/threads/\".concat(threadId,\"/sentence-data\"));return response.data||{memos:{},highlights:[]};}// === 메모 저장고 관련 API (VaultManager 사용) ===\nasync saveMemoToVault(request){const response=await memoVaultManager.create(request);if(response.error){throw new Error(response.error);}return response.data;}async getVaultMemos(){const response=await memoVaultManager.getAll();if(response.error){throw new Error(response.error);}return response.data||[];}async deleteVaultMemo(memoId){const response=await memoVaultManager.delete(memoId);if(response.error){throw new Error(response.error);}return response.data||{success:false,message:'삭제 실패'};}async interactWithVaultMemo(memoId){const response=await memoVaultManager.interact(memoId);if(response.error){throw new Error(response.error);}return response.data;}// === 개발용 API ===\nasync resetDevData(){const response=await apiPost('/dev/reset');if(response.error){throw new Error(response.error);}return response.data;}}export const sentenceApi=new SentenceApi();","map":{"version":3,"names":["apiGet","apiPost","apiDelete","VaultManager","sentenceVaultManager","memoVaultManager","SentenceApi","saveSentencesToVault","request","console","log","JSON","stringify","response","create","error","Error","data","getVaultSentences","getAll","deleteVaultSentence","sentenceId","delete","success","message","updateVaultSentence","update","restoreVaultSentence","vaultSentenceId","concat","createOrUpdateMemo","getMemo","deleteMemo","getAllMemos","createHighlight","deleteHighlight","getAllHighlights","getThreadHighlights","threadId","_response$data","highlights","getThreadSentenceData","memos","saveMemoToVault","getVaultMemos","deleteVaultMemo","memoId","interactWithVaultMemo","interact","resetDevData","sentenceApi"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/training/api/sentenceApi.ts"],"sourcesContent":["import { \n  apiGet, \n  apiPost, \n  apiDelete, \n  VaultManager\n} from '../../shared/utils/apiUtils';\n\nexport interface SentenceVaultItem {\n  id: string;\n  sentence: string;\n  source_message_id: string;\n  source_conversation_id?: string;\n  source_thread_id?: string;  // 원본 스레드 ID\n  source_thread_type?: string;  // 원본 스레드 타입\n  source_sentence_id?: string;  // 원본 문장 ID\n  created_at: string;\n  tags: string[];\n  metadata?: Record<string, any>;\n  \n  // 통합된 문장 상태 정보\n  is_highlighted: boolean;  // 하이라이트 여부\n  highlight_color?: string;  // 하이라이트 색상\n  memo_content?: string;  // 메모 내용\n  is_pinned: boolean;  // 고정 여부\n}\n\nexport interface SentenceVaultRequest {\n  sentences: string[];\n  source_message_id: string;\n  source_conversation_id?: string;\n  source_thread_id?: string;\n  source_thread_type?: string;\n  source_sentence_ids?: string[];  // 원본 문장 ID들\n  tags?: string[];\n  \n  // 각 문장별 상태 정보 (sentences와 동일한 순서)\n  highlight_states?: boolean[];  // 하이라이트 여부\n  highlight_colors?: (string | null)[];  // 하이라이트 색상\n  memo_contents?: (string | null)[];  // 메모 내용\n}\n\nexport interface SentenceVaultResponse {\n  success: boolean;\n  message: string;\n  saved_items: SentenceVaultItem[];\n}\n\nexport interface VaultRestoreRequest {\n  thread_id: string;\n  sentence_id: string;\n}\n\nexport interface VaultRestoreResponse {\n  success: boolean;\n  message: string;\n  restored_highlight: boolean;\n  restored_memo: boolean;\n  highlight_color?: string;\n  memo_content?: string;\n}\n\nexport interface VaultUpdateRequest {\n  is_highlighted?: boolean;\n  highlight_color?: string;\n  memo_content?: string;\n  is_pinned?: boolean;\n  tags?: string[];\n}\n\nexport interface VaultUpdateResponse {\n  success: boolean;\n  message: string;\n  updated_item: SentenceVaultItem;\n}\n\nexport interface SentenceMemo {\n  id: string;\n  sentence_id: string;\n  content: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface SentenceMemoRequest {\n  sentence_id: string;\n  thread_id?: string;\n  thread_type?: string;\n  content: string;\n  sentence_content?: string;  // 메모 저장고 저장을 위한 문장 내용\n  source_message_id?: string;  // 메모 저장고 저장을 위한 메시지 ID\n}\n\nexport interface SentenceMemoResponse {\n  success: boolean;\n  message: string;\n  memo?: SentenceMemo;\n}\n\nexport interface SentenceHighlight {\n  id: string;\n  sentence_id: string;\n  thread_id: string;\n  thread_type: string;\n  created_at: string;\n}\n\nexport interface SentenceHighlightRequest {\n  sentence_id: string;\n  thread_id: string;\n  thread_type: string;\n}\n\nexport interface SentenceHighlightResponse {\n  success: boolean;\n  message: string;\n  highlight?: SentenceHighlight;\n}\n\nexport interface ThreadSentenceData {\n  memos: Record<string, string>;\n  highlights: string[];\n}\n\n// 메모 저장고 관련 타입들\nexport interface MemoVaultItem {\n  id: string;\n  memo_content: string;  // 사용자가 삽입한 메모 내용\n  sentence_content: string;  // 원본 문장 내용\n  source_message_id: string;\n  source_conversation_id?: string;\n  source_thread_id?: string;\n  source_thread_type?: string;\n  source_sentence_id: string;\n  created_at: string;\n  tags: string[];\n  metadata?: Record<string, any>;\n}\n\nexport interface MemoVaultRequest {\n  memo_content: string;  // 사용자가 삽입한 메모\n  sentence_content: string;  // 원본 문장\n  source_message_id: string;\n  source_conversation_id?: string;\n  source_thread_id?: string;\n  source_thread_type?: string;\n  source_sentence_id: string;\n  tags?: string[];\n}\n\nexport interface MemoVaultResponse {\n  success: boolean;\n  message: string;\n  saved_item?: MemoVaultItem;\n}\n\nexport interface MemoVaultInteractionResponse {\n  success: boolean;\n  message: string;\n  interaction_message: string;\n  source_thread_id?: string;\n  source_thread_type?: string;\n  memo_item: MemoVaultItem;\n}\n\n// 저장고 매니저 인스턴스들\nconst sentenceVaultManager = new VaultManager<SentenceVaultItem, SentenceVaultRequest, VaultUpdateRequest>('/vault/sentences');\nconst memoVaultManager = new VaultManager<MemoVaultItem, MemoVaultRequest>('/vault/memos');\n\nclass SentenceApi {\n  // === 문장 저장고 관련 API (VaultManager 사용) ===\n  \n  async saveSentencesToVault(request: SentenceVaultRequest): Promise<SentenceVaultResponse> {\n    console.log('=== 저장고 저장 시작 (통합 API 사용) ===');\n    console.log('요청 데이터:', JSON.stringify(request, null, 2));\n    \n    try {\n      const response = await sentenceVaultManager.create(request);\n      \n      if (response.error) {\n        throw new Error(response.error);\n      }\n      \n      console.log('성공 응답:', response.data);\n      console.log('=== 저장고 저장 완료 ===');\n      return response.data as SentenceVaultResponse;\n      \n    } catch (error: any) {\n      console.error('저장고 저장 오류:', error);\n      throw error;\n    }\n  }\n\n  async getVaultSentences(): Promise<SentenceVaultItem[]> {\n    const response = await sentenceVaultManager.getAll();\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data || [];\n  }\n\n  async deleteVaultSentence(sentenceId: string): Promise<{ success: boolean; message: string }> {\n    const response = await sentenceVaultManager.delete(sentenceId);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data || { success: false, message: '삭제 실패' };\n  }\n\n  async updateVaultSentence(sentenceId: string, request: VaultUpdateRequest): Promise<VaultUpdateResponse> {\n    const response = await sentenceVaultManager.update(sentenceId, request);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data as VaultUpdateResponse;\n  }\n\n  async restoreVaultSentence(vaultSentenceId: string, request: VaultRestoreRequest): Promise<VaultRestoreResponse> {\n    const response = await apiPost<VaultRestoreResponse>(`/vault/sentences/${vaultSentenceId}/restore`, request);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data!;\n  }\n\n  // === 메모 관련 API (통합) ===\n  \n  async createOrUpdateMemo(request: SentenceMemoRequest): Promise<SentenceMemoResponse> {\n    const response = await apiPost<SentenceMemoResponse>('/memos', request);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data!;\n  }\n\n  async getMemo(sentenceId: string): Promise<SentenceMemo | null> {\n    const response = await apiGet<SentenceMemo>(`/memos/${sentenceId}`);\n    return response.data || null;\n  }\n\n  async deleteMemo(sentenceId: string): Promise<{ success: boolean; message: string }> {\n    const response = await apiDelete<{ success: boolean; message: string }>(`/memos/${sentenceId}`);\n    if (response.data) {\n      return response.data;\n    }\n    // 404는 이미 삭제된 것으로 간주\n    return { success: true, message: '메모가 이미 삭제되었습니다' };\n  }\n\n  async getAllMemos(): Promise<Record<string, string>> {\n    const response = await apiGet<Record<string, string>>('/memos');\n    return response.data || {};\n  }\n\n  // === 하이라이트 관련 API (통합) ===\n  \n  async createHighlight(request: SentenceHighlightRequest): Promise<SentenceHighlightResponse> {\n    const response = await apiPost<SentenceHighlightResponse>('/highlights', request);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data!;\n  }\n\n  async deleteHighlight(sentenceId: string): Promise<{ success: boolean; message: string }> {\n    const response = await apiDelete<{ success: boolean; message: string }>(`/highlights/${sentenceId}`);\n    if (response.data) {\n      return response.data;\n    }\n    // 404는 이미 삭제된 것으로 간주\n    return { success: true, message: '하이라이트가 이미 삭제되었습니다' };\n  }\n\n  async getAllHighlights(): Promise<Record<string, string[]>> {\n    const response = await apiGet<Record<string, string[]>>('/highlights');\n    return response.data || {};\n  }\n\n  async getThreadHighlights(threadId: string): Promise<string[]> {\n    const response = await apiGet<{ highlights: string[] }>(`/highlights/thread/${threadId}`);\n    return response.data?.highlights || [];\n  }\n\n  // === 스레드 관련 API ===\n  \n  async getThreadSentenceData(threadId: string): Promise<ThreadSentenceData> {\n    const response = await apiGet<ThreadSentenceData>(`/threads/${threadId}/sentence-data`);\n    return response.data || { memos: {}, highlights: [] };\n  }\n\n  // === 메모 저장고 관련 API (VaultManager 사용) ===\n  \n  async saveMemoToVault(request: MemoVaultRequest): Promise<MemoVaultResponse> {\n    const response = await memoVaultManager.create(request);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data as MemoVaultResponse;\n  }\n\n  async getVaultMemos(): Promise<MemoVaultItem[]> {\n    const response = await memoVaultManager.getAll();\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data || [];\n  }\n\n  async deleteVaultMemo(memoId: string): Promise<{ success: boolean; message: string }> {\n    const response = await memoVaultManager.delete(memoId);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data || { success: false, message: '삭제 실패' };\n  }\n\n  async interactWithVaultMemo(memoId: string): Promise<MemoVaultInteractionResponse> {\n    const response = await memoVaultManager.interact(memoId);\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data as MemoVaultInteractionResponse;\n  }\n\n  // === 개발용 API ===\n  \n  async resetDevData(): Promise<{ success: boolean; message: string }> {\n    const response = await apiPost<{ success: boolean; message: string }>('/dev/reset');\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.data!;\n  }\n}\n\nexport const sentenceApi = new SentenceApi();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}