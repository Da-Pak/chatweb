{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef, useState, useCallback } from 'react';\nexport const useRecorder = () => {\n  _s();\n  const mediaRecorderRef = useRef(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [error, setError] = useState(null);\n  const startRecording = useCallback(async () => {\n    if (isRecording) return;\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      const chunks = [];\n      mediaRecorder.ondataavailable = e => {\n        if (e.data.size > 0) chunks.push(e.data);\n      };\n      mediaRecorder.onstop = () => {\n        const blob = new Blob(chunks, {\n          type: 'audio/webm'\n        });\n        if (onStopCb.current) onStopCb.current(blob);\n      };\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (e) {\n      setError(e.message);\n    }\n  }, [isRecording]);\n  const onStopCb = useRef();\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach(t => t.stop());\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n  const record = useCallback(async onStop => {\n    onStopCb.current = onStop;\n    await startRecording();\n  }, [startRecording]);\n  return {\n    isRecording,\n    error,\n    record,\n    stopRecording\n  };\n};\n_s(useRecorder, \"uGTxKgje0zjr+bOOuriK0xCVLDE=\");","map":{"version":3,"names":["useRef","useState","useCallback","useRecorder","_s","mediaRecorderRef","isRecording","setIsRecording","error","setError","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","mimeType","current","chunks","ondataavailable","e","data","size","push","onstop","blob","Blob","type","onStopCb","start","message","stopRecording","stop","getTracks","forEach","t","record","onStop"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/onboarding/hooks/useRecorder.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\n\r\nexport const useRecorder = () => {\r\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const startRecording = useCallback(async () => {\r\n    if (isRecording) return;\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      const mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });\r\n      mediaRecorderRef.current = mediaRecorder;\r\n      const chunks: BlobPart[] = [];\r\n\r\n      mediaRecorder.ondataavailable = (e) => {\r\n        if (e.data.size > 0) chunks.push(e.data);\r\n      };\r\n\r\n      mediaRecorder.onstop = () => {\r\n        const blob = new Blob(chunks, { type: 'audio/webm' });\r\n        if (onStopCb.current) onStopCb.current(blob);\r\n      };\r\n\r\n      mediaRecorder.start();\r\n      setIsRecording(true);\r\n    } catch (e: any) {\r\n      setError(e.message);\r\n    }\r\n  }, [isRecording]);\r\n\r\n  const onStopCb = useRef<(blob: Blob) => void>();\r\n  const stopRecording = useCallback(() => {\r\n    if (mediaRecorderRef.current && isRecording) {\r\n      mediaRecorderRef.current.stop();\r\n      mediaRecorderRef.current.stream.getTracks().forEach(t => t.stop());\r\n      setIsRecording(false);\r\n    }\r\n  }, [isRecording]);\r\n\r\n  const record = useCallback(async (onStop: (blob: Blob) => void) => {\r\n    onStopCb.current = onStop;\r\n    await startRecording();\r\n  }, [startRecording]);\r\n\r\n  return { isRecording, error, record, stopRecording };\r\n}; "],"mappings":";AAAA,SAAoBA,MAAM,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAEhE,OAAO,MAAMC,WAAW,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC/B,MAAMC,gBAAgB,GAAGL,MAAM,CAAuB,IAAI,CAAC;EAC3D,MAAM,CAACM,WAAW,EAAEC,cAAc,CAAC,GAAGN,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACO,KAAK,EAAEC,QAAQ,CAAC,GAAGR,QAAQ,CAAgB,IAAI,CAAC;EAEvD,MAAMS,cAAc,GAAGR,WAAW,CAAC,YAAY;IAC7C,IAAII,WAAW,EAAE;IACjB,IAAI;MACF,MAAMK,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,MAAMC,aAAa,GAAG,IAAIC,aAAa,CAACN,MAAM,EAAE;QAAEO,QAAQ,EAAE;MAAa,CAAC,CAAC;MAC3Eb,gBAAgB,CAACc,OAAO,GAAGH,aAAa;MACxC,MAAMI,MAAkB,GAAG,EAAE;MAE7BJ,aAAa,CAACK,eAAe,GAAIC,CAAC,IAAK;QACrC,IAAIA,CAAC,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAEJ,MAAM,CAACK,IAAI,CAACH,CAAC,CAACC,IAAI,CAAC;MAC1C,CAAC;MAEDP,aAAa,CAACU,MAAM,GAAG,MAAM;QAC3B,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACR,MAAM,EAAE;UAAES,IAAI,EAAE;QAAa,CAAC,CAAC;QACrD,IAAIC,QAAQ,CAACX,OAAO,EAAEW,QAAQ,CAACX,OAAO,CAACQ,IAAI,CAAC;MAC9C,CAAC;MAEDX,aAAa,CAACe,KAAK,CAAC,CAAC;MACrBxB,cAAc,CAAC,IAAI,CAAC;IACtB,CAAC,CAAC,OAAOe,CAAM,EAAE;MACfb,QAAQ,CAACa,CAAC,CAACU,OAAO,CAAC;IACrB;EACF,CAAC,EAAE,CAAC1B,WAAW,CAAC,CAAC;EAEjB,MAAMwB,QAAQ,GAAG9B,MAAM,CAAuB,CAAC;EAC/C,MAAMiC,aAAa,GAAG/B,WAAW,CAAC,MAAM;IACtC,IAAIG,gBAAgB,CAACc,OAAO,IAAIb,WAAW,EAAE;MAC3CD,gBAAgB,CAACc,OAAO,CAACe,IAAI,CAAC,CAAC;MAC/B7B,gBAAgB,CAACc,OAAO,CAACR,MAAM,CAACwB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,CAAC,IAAIA,CAAC,CAACH,IAAI,CAAC,CAAC,CAAC;MAClE3B,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC,EAAE,CAACD,WAAW,CAAC,CAAC;EAEjB,MAAMgC,MAAM,GAAGpC,WAAW,CAAC,MAAOqC,MAA4B,IAAK;IACjET,QAAQ,CAACX,OAAO,GAAGoB,MAAM;IACzB,MAAM7B,cAAc,CAAC,CAAC;EACxB,CAAC,EAAE,CAACA,cAAc,CAAC,CAAC;EAEpB,OAAO;IAAEJ,WAAW;IAAEE,KAAK;IAAE8B,MAAM;IAAEL;EAAc,CAAC;AACtD,CAAC;AAAC7B,EAAA,CA5CWD,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}