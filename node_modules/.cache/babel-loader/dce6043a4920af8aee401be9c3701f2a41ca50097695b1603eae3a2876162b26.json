{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback } from 'react';\nexport const useWhisperStream = onTranscriptUpdate => {\n  _s();\n  const [status, setStatus] = useState('idle');\n  const mediaRecorderRef = useRef(null);\n  const websocketRef = useRef(null);\n  const stopRecording = useCallback(() => {\n    var _mediaRecorderRef$cur;\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {\n      websocketRef.current.close();\n    }\n    if ((_mediaRecorderRef$cur = mediaRecorderRef.current) !== null && _mediaRecorderRef$cur !== void 0 && _mediaRecorderRef$cur.stream) {\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n    }\n    setStatus('idle');\n  }, []);\n  const startRecording = useCallback(async () => {\n    setStatus('connecting');\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n\n      // WebSocket 연결\n      const ws = new WebSocket('ws://localhost:8000/api/stt/stream');\n      websocketRef.current = ws;\n      ws.onopen = () => {\n        console.log(\"WebSocket 연결 성공\");\n        mediaRecorderRef.current = new MediaRecorder(stream, {\n          mimeType: 'audio/webm'\n        });\n        mediaRecorderRef.current.ondataavailable = event => {\n          if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {\n            ws.send(event.data);\n          }\n        };\n        mediaRecorderRef.current.onstop = () => {\n          stopRecording();\n        };\n\n        // 1초마다 음성 데이터를 서버로 전송\n        mediaRecorderRef.current.start(1000);\n        setStatus('recording');\n      };\n      ws.onmessage = event => {\n        onTranscriptUpdate(event.data);\n      };\n      ws.onerror = error => {\n        console.error(\"WebSocket 오류:\", error);\n        setStatus('error');\n        stopRecording();\n      };\n      ws.onclose = () => {\n        console.log(\"WebSocket 연결 종료\");\n        if (status !== 'idle') {\n          stopRecording();\n        }\n      };\n    } catch (error) {\n      console.error(\"마이크 접근 실패:\", error);\n      setStatus('error');\n    }\n  }, [onTranscriptUpdate, stopRecording, status]);\n  const toggleRecording = useCallback(() => {\n    if (status === 'recording') {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  }, [status, startRecording, stopRecording]);\n  return {\n    status,\n    toggleRecording\n  };\n};\n_s(useWhisperStream, \"TpEByOfLppM1GjAUe50raxDJcMY=\");","map":{"version":3,"names":["useState","useRef","useCallback","useWhisperStream","onTranscriptUpdate","_s","status","setStatus","mediaRecorderRef","websocketRef","stopRecording","_mediaRecorderRef$cur","current","state","stop","readyState","WebSocket","OPEN","close","stream","getTracks","forEach","track","startRecording","navigator","mediaDevices","getUserMedia","audio","ws","onopen","console","log","MediaRecorder","mimeType","ondataavailable","event","data","size","send","onstop","start","onmessage","onerror","error","onclose","toggleRecording"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/qa/hooks/useWhisperStream.ts"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\r\n\r\nexport type RecordingStatus = 'idle' | 'connecting' | 'recording' | 'stopping' | 'error';\r\n\r\nexport const useWhisperStream = (onTranscriptUpdate: (text: string) => void) => {\r\n    const [status, setStatus] = useState<RecordingStatus>('idle');\r\n    const mediaRecorderRef = useRef<MediaRecorder | null>(null);\r\n    const websocketRef = useRef<WebSocket | null>(null);\r\n\r\n    const stopRecording = useCallback(() => {\r\n        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\r\n            mediaRecorderRef.current.stop();\r\n        }\r\n        if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {\r\n            websocketRef.current.close();\r\n        }\r\n        if (mediaRecorderRef.current?.stream) {\r\n            mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\r\n        }\r\n        setStatus('idle');\r\n    }, []);\r\n\r\n    const startRecording = useCallback(async () => {\r\n        setStatus('connecting');\r\n        try {\r\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n            \r\n            // WebSocket 연결\r\n            const ws = new WebSocket('ws://localhost:8000/api/stt/stream');\r\n            websocketRef.current = ws;\r\n\r\n            ws.onopen = () => {\r\n                console.log(\"WebSocket 연결 성공\");\r\n                mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: 'audio/webm' });\r\n                \r\n                mediaRecorderRef.current.ondataavailable = (event) => {\r\n                    if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {\r\n                        ws.send(event.data);\r\n                    }\r\n                };\r\n                \r\n                mediaRecorderRef.current.onstop = () => {\r\n                    stopRecording();\r\n                };\r\n                \r\n                // 1초마다 음성 데이터를 서버로 전송\r\n                mediaRecorderRef.current.start(1000); \r\n                setStatus('recording');\r\n            };\r\n\r\n            ws.onmessage = (event) => {\r\n                onTranscriptUpdate(event.data);\r\n            };\r\n\r\n            ws.onerror = (error) => {\r\n                console.error(\"WebSocket 오류:\", error);\r\n                setStatus('error');\r\n                stopRecording();\r\n            };\r\n\r\n            ws.onclose = () => {\r\n                console.log(\"WebSocket 연결 종료\");\r\n                if (status !== 'idle') {\r\n                    stopRecording();\r\n                }\r\n            };\r\n        } catch (error) {\r\n            console.error(\"마이크 접근 실패:\", error);\r\n            setStatus('error');\r\n        }\r\n    }, [onTranscriptUpdate, stopRecording, status]);\r\n\r\n    const toggleRecording = useCallback(() => {\r\n        if (status === 'recording') {\r\n            stopRecording();\r\n        } else {\r\n            startRecording();\r\n        }\r\n    }, [status, startRecording, stopRecording]);\r\n\r\n    return { status, toggleRecording };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}