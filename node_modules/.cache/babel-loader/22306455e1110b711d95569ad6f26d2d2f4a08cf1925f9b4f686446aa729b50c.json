{"ast":null,"code":"import _objectSpread from\"C:/Users/sungh/Desktop/chat_work_ver2/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useState}from'react';import{sentenceApi}from'../../training/api/sentenceApi';import{useToast}from'./useToast';import{useClipboard}from'./useClipboard';export const useSentenceMenu=_ref=>{let{personaId,threadType,selectedThread,memos,highlightedSentences,setMemos,setHighlightedSentences}=_ref;const{showCopyToast}=useToast();const{copyTextToClipboard}=useClipboard();const[selectedSentences,setSelectedSentences]=useState(new Set());const handleSaveToVault=async(selectedIds,selectedTexts)=>{try{if(!selectedTexts.length){showCopyToast('저장할 문장을 선택해주세요');return;}if(!(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id)){showCopyToast('저장할 스레드를 선택해주세요');return;}// 하이라이트/메모 상태 수집\nconst highlightStates=[];const highlightColors=[];const memoContents=[];for(const sentenceId of selectedIds){const isHighlighted=highlightedSentences.has(sentenceId);const memoContent=memos[sentenceId]||null;highlightStates.push(isHighlighted);highlightColors.push(isHighlighted?'yellow':null);memoContents.push(memoContent);}await sentenceApi.saveSentencesToVault({sentences:selectedTexts,source_message_id:\"\".concat(threadType,\"_\").concat(personaId),source_conversation_id:selectedThread.id,source_thread_id:selectedThread.id,source_thread_type:threadType,source_sentence_ids:selectedIds,tags:[threadType,personaId],highlight_states:highlightStates,highlight_colors:highlightColors,memo_contents:memoContents});// 백엔드에 하이라이트도 저장\nfor(const sentenceId of selectedIds){await sentenceApi.createHighlight({sentence_id:sentenceId,thread_id:selectedThread.id,thread_type:threadType});}// 성공 시 로컬 상태 업데이트\nsetHighlightedSentences(prev=>new Set([...Array.from(prev),...selectedIds]));showCopyToast('저장고에 저장되었습니다 (하이라이트/메모 정보 포함)');}catch(error){console.error('저장고 저장 실패:',error);showCopyToast('저장고 저장에 실패했습니다');}};const handleAddMemo=async(selectedIds,selectedTexts)=>{if(selectedIds.length===0)return;try{// 백엔드에 모든 선택된 문장의 하이라이트 저장\nif(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id){for(const sentenceId of selectedIds){await sentenceApi.createHighlight({sentence_id:sentenceId,thread_id:selectedThread.id,thread_type:threadType});}}// 마지막 문장 ID 찾기 (가장 큰 인덱스)\nconst sortedIds=selectedIds.sort();const lastSentenceId=sortedIds[sortedIds.length-1];// 마지막 문장에만 빈 메모 추가\nconst newMemos={[lastSentenceId]:''};// 메모에 연관된 문장들 정보 저장 (메타데이터로)\nconst relatedSentenceIds=selectedIds;const relatedSentenceTexts=selectedTexts;console.log('=== 메모 생성 정보 ===');console.log('마지막 문장 ID:',lastSentenceId);console.log('연관된 문장 ID들:',relatedSentenceIds);console.log('연관된 문장 텍스트들:',relatedSentenceTexts);// 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\nif(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id){try{await sentenceApi.createOrUpdateMemo({sentence_id:lastSentenceId,thread_id:selectedThread.id,thread_type:threadType,content:'',// 빈 메모로 시작\nrelated_sentence_ids:relatedSentenceIds,related_sentence_contents:relatedSentenceTexts,sentence_content:selectedTexts[selectedTexts.length-1],// 마지막 문장 내용\nsource_message_id:\"\".concat(threadType,\"_memo_\").concat(Date.now())});}catch(error){console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):',error);}}// 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\nsetMemos(prev=>_objectSpread(_objectSpread({},prev),newMemos));setHighlightedSentences(prev=>new Set([...Array.from(prev),...selectedIds]));// 선택된 문장이 여러 개인 경우 안내 메시지\nif(selectedIds.length>1){showCopyToast(\"\\uBA54\\uBAA8\\uAC00 \\uB9C8\\uC9C0\\uB9C9 \\uBB38\\uC7A5\\uC5D0 \\uC0DD\\uC131\\uB418\\uC5C8\\uC2B5\\uB2C8\\uB2E4 (\\uC5F0\\uAD00 \\uBB38\\uC7A5: \".concat(selectedIds.length,\"\\uAC1C)\"));}else{showCopyToast('메모와 하이라이트가 추가되었습니다');}}catch(error){console.error('메모/하이라이트 추가 실패:',error);showCopyToast('메모/하이라이트 추가에 실패했습니다');}};const handleToggleHighlight=async selectedIds=>{if(!selectedIds.length||!(selectedThread!==null&&selectedThread!==void 0&&selectedThread.id))return;try{const currentlyHighlighted=selectedIds.filter(id=>highlightedSentences.has(id));if(currentlyHighlighted.length>0){// 하이라이트 제거\nsetHighlightedSentences(prev=>{const newSet=new Set(prev);selectedIds.forEach(id=>newSet.delete(id));return newSet;});// 백엔드에서 하이라이트 삭제\nfor(const sentenceId of selectedIds){try{await sentenceApi.deleteHighlight(sentenceId);}catch(error){console.warn('백엔드 하이라이트 삭제 실패:',error);}}showCopyToast('하이라이트가 제거되었습니다');}else{// 하이라이트 추가\nsetHighlightedSentences(prev=>new Set([...Array.from(prev),...selectedIds]));// 백엔드에 하이라이트 저장\nfor(const sentenceId of selectedIds){try{await sentenceApi.createHighlight({sentence_id:sentenceId,thread_id:selectedThread.id,thread_type:threadType});}catch(error){console.warn('백엔드 하이라이트 저장 실패:',error);}}showCopyToast('하이라이트가 추가되었습니다');}}catch(error){console.error('하이라이트 토글 실패:',error);showCopyToast('하이라이트 처리에 실패했습니다');}};const handleMenuAction=async(action,selectedIds,selectedTexts,messageInputRef)=>{switch(action){case'sendToInput':if(messageInputRef!==null&&messageInputRef!==void 0&&messageInputRef.current&&selectedTexts.length>0){const formattedText=selectedTexts.map(text=>\"\\\"\".concat(text,\"\\\"\")).join(', ');messageInputRef.current.insertText(formattedText);showCopyToast('선택한 문장이 입력창에 추가되었습니다');}break;case'saveToVault':await handleSaveToVault(selectedIds,selectedTexts);break;case'addMemo':await handleAddMemo(selectedIds,selectedTexts);break;case'highlight':await handleToggleHighlight(selectedIds);break;case'copy':if(selectedTexts.length>0){await copyTextToClipboard(selectedTexts.join(' '),'선택된 문장이 복사되었습니다');}break;}// 모든 선택 해제\nsetSelectedSentences(new Set());};return{selectedSentences,setSelectedSentences,handleMenuAction,handleSaveToVault,handleAddMemo,handleToggleHighlight};};","map":{"version":3,"names":["useState","sentenceApi","useToast","useClipboard","useSentenceMenu","_ref","personaId","threadType","selectedThread","memos","highlightedSentences","setMemos","setHighlightedSentences","showCopyToast","copyTextToClipboard","selectedSentences","setSelectedSentences","Set","handleSaveToVault","selectedIds","selectedTexts","length","id","highlightStates","highlightColors","memoContents","sentenceId","isHighlighted","has","memoContent","push","saveSentencesToVault","sentences","source_message_id","concat","source_conversation_id","source_thread_id","source_thread_type","source_sentence_ids","tags","highlight_states","highlight_colors","memo_contents","createHighlight","sentence_id","thread_id","thread_type","prev","Array","from","error","console","handleAddMemo","sortedIds","sort","lastSentenceId","newMemos","relatedSentenceIds","relatedSentenceTexts","log","createOrUpdateMemo","content","related_sentence_ids","related_sentence_contents","sentence_content","Date","now","warn","_objectSpread","handleToggleHighlight","currentlyHighlighted","filter","newSet","forEach","delete","deleteHighlight","handleMenuAction","action","messageInputRef","current","formattedText","map","text","join","insertText"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/shared/hooks/useSentenceMenu.ts"],"sourcesContent":["import { useState } from 'react';\nimport { sentenceApi } from '../../training/api/sentenceApi';\nimport { useToast } from './useToast';\nimport { useClipboard } from './useClipboard';\nimport { TrainingThread } from '../types';\n\ninterface UseSentenceMenuProps {\n  personaId: string;\n  threadType: 'interpretation' | 'proceed' | 'sentence' | 'verbalization';\n  selectedThread?: TrainingThread | null;\n  memos: Record<string, string>;\n  highlightedSentences: Set<string>;\n  setMemos: React.Dispatch<React.SetStateAction<Record<string, string>>>;\n  setHighlightedSentences: React.Dispatch<React.SetStateAction<Set<string>>>;\n}\n\nexport const useSentenceMenu = ({\n  personaId,\n  threadType,\n  selectedThread,\n  memos,\n  highlightedSentences,\n  setMemos,\n  setHighlightedSentences\n}: UseSentenceMenuProps) => {\n  const { showCopyToast } = useToast();\n  const { copyTextToClipboard } = useClipboard();\n  const [selectedSentences, setSelectedSentences] = useState<Set<string>>(new Set());\n\n  const handleSaveToVault = async (selectedIds: string[], selectedTexts: string[]) => {\n    try {\n      if (!selectedTexts.length) {\n        showCopyToast('저장할 문장을 선택해주세요');\n        return;\n      }\n\n      if (!selectedThread?.id) {\n        showCopyToast('저장할 스레드를 선택해주세요');\n        return;\n      }\n\n      // 하이라이트/메모 상태 수집\n      const highlightStates: boolean[] = [];\n      const highlightColors: (string | null)[] = [];\n      const memoContents: (string | null)[] = [];\n      \n      for (const sentenceId of selectedIds) {\n        const isHighlighted = highlightedSentences.has(sentenceId);\n        const memoContent = memos[sentenceId] || null;\n        \n        highlightStates.push(isHighlighted);\n        highlightColors.push(isHighlighted ? 'yellow' : null);\n        memoContents.push(memoContent);\n      }\n\n      await sentenceApi.saveSentencesToVault({\n        sentences: selectedTexts,\n        source_message_id: `${threadType}_${personaId}`,\n        source_conversation_id: selectedThread.id,\n        source_thread_id: selectedThread.id,\n        source_thread_type: threadType,\n        source_sentence_ids: selectedIds,\n        tags: [threadType, personaId],\n        highlight_states: highlightStates,\n        highlight_colors: highlightColors,\n        memo_contents: memoContents\n      });\n      \n      // 백엔드에 하이라이트도 저장\n      for (const sentenceId of selectedIds) {\n        await sentenceApi.createHighlight({\n          sentence_id: sentenceId,\n          thread_id: selectedThread.id,\n          thread_type: threadType\n        });\n      }\n      \n      // 성공 시 로컬 상태 업데이트\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      showCopyToast('저장고에 저장되었습니다 (하이라이트/메모 정보 포함)');\n    } catch (error) {\n      console.error('저장고 저장 실패:', error);\n      showCopyToast('저장고 저장에 실패했습니다');\n    }\n  };\n\n  const handleAddMemo = async (selectedIds: string[], selectedTexts: string[]) => {\n    if (selectedIds.length === 0) return;\n\n    try {\n      // 백엔드에 모든 선택된 문장의 하이라이트 저장\n      if (selectedThread?.id) {\n        for (const sentenceId of selectedIds) {\n          await sentenceApi.createHighlight({\n            sentence_id: sentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType\n          });\n        }\n      }\n      \n      // 마지막 문장 ID 찾기 (가장 큰 인덱스)\n      const sortedIds = selectedIds.sort();\n      const lastSentenceId = sortedIds[sortedIds.length - 1];\n      \n      // 마지막 문장에만 빈 메모 추가\n      const newMemos: Record<string, string> = {\n        [lastSentenceId]: ''\n      };\n      \n      // 메모에 연관된 문장들 정보 저장 (메타데이터로)\n      const relatedSentenceIds = selectedIds;\n      const relatedSentenceTexts = selectedTexts;\n      \n      console.log('=== 메모 생성 정보 ===');\n      console.log('마지막 문장 ID:', lastSentenceId);\n      console.log('연관된 문장 ID들:', relatedSentenceIds);\n      console.log('연관된 문장 텍스트들:', relatedSentenceTexts);\n      \n      // 백엔드에 메모 생성 요청 (연관된 문장들 정보 포함)\n      if (selectedThread?.id) {\n        try {\n          await sentenceApi.createOrUpdateMemo({\n            sentence_id: lastSentenceId,\n            thread_id: selectedThread.id,\n            thread_type: threadType,\n            content: '', // 빈 메모로 시작\n            related_sentence_ids: relatedSentenceIds,\n            related_sentence_contents: relatedSentenceTexts,\n            sentence_content: selectedTexts[selectedTexts.length - 1], // 마지막 문장 내용\n            source_message_id: `${threadType}_memo_${Date.now()}`\n          } as any);\n        } catch (error) {\n          console.warn('백엔드 메모 생성 실패 (로컬 생성은 성공):', error);\n        }\n      }\n      \n      // 로컬 상태 업데이트: 마지막 문장에만 메모 생성, 모든 문장 하이라이트\n      setMemos(prev => ({ ...prev, ...newMemos }));\n      setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n      \n      // 선택된 문장이 여러 개인 경우 안내 메시지\n      if (selectedIds.length > 1) {\n        showCopyToast(`메모가 마지막 문장에 생성되었습니다 (연관 문장: ${selectedIds.length}개)`);\n      } else {\n        showCopyToast('메모와 하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('메모/하이라이트 추가 실패:', error);\n      showCopyToast('메모/하이라이트 추가에 실패했습니다');\n    }\n  };\n\n  const handleToggleHighlight = async (selectedIds: string[]) => {\n    if (!selectedIds.length || !selectedThread?.id) return;\n\n    try {\n      const currentlyHighlighted = selectedIds.filter(id => highlightedSentences.has(id));\n      \n      if (currentlyHighlighted.length > 0) {\n        // 하이라이트 제거\n        setHighlightedSentences(prev => {\n          const newSet = new Set(prev);\n          selectedIds.forEach(id => newSet.delete(id));\n          return newSet;\n        });\n        \n        // 백엔드에서 하이라이트 삭제\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.deleteHighlight(sentenceId);\n          } catch (error) {\n            console.warn('백엔드 하이라이트 삭제 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 제거되었습니다');\n      } else {\n        // 하이라이트 추가\n        setHighlightedSentences(prev => new Set([...Array.from(prev), ...selectedIds]));\n        \n        // 백엔드에 하이라이트 저장\n        for (const sentenceId of selectedIds) {\n          try {\n            await sentenceApi.createHighlight({\n              sentence_id: sentenceId,\n              thread_id: selectedThread.id,\n              thread_type: threadType\n            });\n          } catch (error) {\n            console.warn('백엔드 하이라이트 저장 실패:', error);\n          }\n        }\n        \n        showCopyToast('하이라이트가 추가되었습니다');\n      }\n    } catch (error) {\n      console.error('하이라이트 토글 실패:', error);\n      showCopyToast('하이라이트 처리에 실패했습니다');\n    }\n  };\n\n  const handleMenuAction = async (\n    action: 'sendToInput' | 'saveToVault' | 'addMemo' | 'highlight' | 'copy',\n    selectedIds: string[],\n    selectedTexts: string[],\n    messageInputRef?: React.RefObject<any>\n  ) => {\n    switch (action) {\n      case 'sendToInput':\n        if (messageInputRef?.current && selectedTexts.length > 0) {\n          const formattedText = selectedTexts.map(text => `\"${text}\"`).join(', ');\n          messageInputRef.current.insertText(formattedText);\n          showCopyToast('선택한 문장이 입력창에 추가되었습니다');\n        }\n        break;\n      \n      case 'saveToVault':\n        await handleSaveToVault(selectedIds, selectedTexts);\n        break;\n      \n      case 'addMemo':\n        await handleAddMemo(selectedIds, selectedTexts);\n        break;\n      \n      case 'highlight':\n        await handleToggleHighlight(selectedIds);\n        break;\n      \n      case 'copy':\n        if (selectedTexts.length > 0) {\n          await copyTextToClipboard(selectedTexts.join(' '), '선택된 문장이 복사되었습니다');\n        }\n        break;\n    }\n\n    // 모든 선택 해제\n    setSelectedSentences(new Set());\n  };\n\n  return {\n    selectedSentences,\n    setSelectedSentences,\n    handleMenuAction,\n    handleSaveToVault,\n    handleAddMemo,\n    handleToggleHighlight\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}