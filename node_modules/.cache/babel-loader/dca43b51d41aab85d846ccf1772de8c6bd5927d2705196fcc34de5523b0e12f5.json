{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback } from 'react';\nexport const useVoiceToText = onTranscriptReceived => {\n  _s();\n  const [status, setStatus] = useState(\"idle\");\n  const mediaRecorderRef = useRef(null);\n  const webSocketRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === \"recording\") {\n      mediaRecorderRef.current.stop();\n    }\n    if (webSocketRef.current && webSocketRef.current.readyState === WebSocket.OPEN) {\n      webSocketRef.current.close();\n    }\n    setStatus(\"idle\");\n  }, []);\n  const startRecording = useCallback(async () => {\n    if (status === \"recording\") {\n      stopRecording();\n      return;\n    }\n    setStatus(\"connecting\");\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const wsUrl = process.env.REACT_APP_WEBSOCKET_URL || 'ws://localhost:8000/api/qa/voice';\n      const ws = new WebSocket(wsUrl);\n      webSocketRef.current = ws;\n      ws.onopen = () => {\n        console.log(\"WebSocket 연결 성공\");\n        setStatus(\"recording\");\n        mediaRecorderRef.current = new MediaRecorder(stream, {\n          mimeType: 'audio/webm'\n        });\n        audioChunksRef.current = [];\n        mediaRecorderRef.current.ondataavailable = event => {\n          if (event.data.size > 0) {\n            audioChunksRef.current.push(event.data);\n            const audioBlob = new Blob(audioChunksRef.current, {\n              type: 'audio/webm'\n            });\n            ws.send(audioBlob);\n            audioChunksRef.current = []; // 청크를 보낸 후 초기화\n          }\n        };\n        mediaRecorderRef.current.onstop = () => {\n          stream.getTracks().forEach(track => track.stop());\n          if (ws.readyState === WebSocket.OPEN) {\n            ws.close();\n          }\n        };\n        ws.onmessage = event => {\n          onTranscriptReceived(event.data);\n        };\n        ws.onerror = error => {\n          console.error(\"WebSocket 오류:\", error);\n          setStatus(\"error\");\n          stopRecording();\n        };\n        ws.onclose = () => {\n          console.log(\"WebSocket 연결 종료\");\n          setStatus(\"idle\");\n          if (mediaRecorderRef.current && mediaRecorderRef.current.state === \"recording\") {\n            stopRecording();\n          }\n        };\n        mediaRecorderRef.current.start(2000); // 2초마다 데이터를 청크로 분할\n      };\n    } catch (error) {\n      console.error(\"마이크 접근 오류:\", error);\n      setStatus(\"error\");\n    }\n  }, [status, onTranscriptReceived, stopRecording]);\n  return {\n    status,\n    startRecording,\n    stopRecording\n  };\n};\n_s(useVoiceToText, \"Nn2U3nTG8Zo0Pz70RFMGJNkIslU=\");","map":{"version":3,"names":["useState","useRef","useCallback","useVoiceToText","onTranscriptReceived","_s","status","setStatus","mediaRecorderRef","webSocketRef","audioChunksRef","stopRecording","current","state","stop","readyState","WebSocket","OPEN","close","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","wsUrl","process","env","REACT_APP_WEBSOCKET_URL","ws","onopen","console","log","MediaRecorder","mimeType","ondataavailable","event","data","size","push","audioBlob","Blob","type","send","onstop","getTracks","forEach","track","onmessage","onerror","error","onclose","start"],"sources":["C:/Users/sungh/Desktop/chat_work_ver2/frontend/src/features/qa/hooks/useVoiceToText.ts"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\r\n\r\nexport type RecordingStatus = \"idle\" | \"recording\" | \"connecting\" | \"error\";\r\n\r\nexport const useVoiceToText = (onTranscriptReceived: (transcript: string) => void) => {\r\n  const [status, setStatus] = useState<RecordingStatus>(\"idle\");\r\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\r\n  const webSocketRef = useRef<WebSocket | null>(null);\r\n  const audioChunksRef = useRef<Blob[]>([]);\r\n\r\n  const stopRecording = useCallback(() => {\r\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === \"recording\") {\r\n      mediaRecorderRef.current.stop();\r\n    }\r\n    if (webSocketRef.current && webSocketRef.current.readyState === WebSocket.OPEN) {\r\n      webSocketRef.current.close();\r\n    }\r\n    setStatus(\"idle\");\r\n  }, []);\r\n\r\n  const startRecording = useCallback(async () => {\r\n    if (status === \"recording\") {\r\n      stopRecording();\r\n      return;\r\n    }\r\n\r\n    setStatus(\"connecting\");\r\n\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      \r\n      const wsUrl = process.env.REACT_APP_WEBSOCKET_URL || 'ws://localhost:8000/api/qa/voice';\r\n      const ws = new WebSocket(wsUrl);\r\n      webSocketRef.current = ws;\r\n\r\n      ws.onopen = () => {\r\n        console.log(\"WebSocket 연결 성공\");\r\n        setStatus(\"recording\");\r\n\r\n        mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: 'audio/webm' });\r\n        audioChunksRef.current = [];\r\n\r\n        mediaRecorderRef.current.ondataavailable = (event) => {\r\n          if (event.data.size > 0) {\r\n            audioChunksRef.current.push(event.data);\r\n            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\r\n            ws.send(audioBlob);\r\n            audioChunksRef.current = []; // 청크를 보낸 후 초기화\r\n          }\r\n        };\r\n\r\n        mediaRecorderRef.current.onstop = () => {\r\n          stream.getTracks().forEach(track => track.stop());\r\n          if (ws.readyState === WebSocket.OPEN) {\r\n            ws.close();\r\n          }\r\n        };\r\n\r\n        ws.onmessage = (event) => {\r\n          onTranscriptReceived(event.data);\r\n        };\r\n\r\n        ws.onerror = (error) => {\r\n          console.error(\"WebSocket 오류:\", error);\r\n          setStatus(\"error\");\r\n          stopRecording();\r\n        };\r\n\r\n        ws.onclose = () => {\r\n          console.log(\"WebSocket 연결 종료\");\r\n          setStatus(\"idle\");\r\n          if (mediaRecorderRef.current && mediaRecorderRef.current.state === \"recording\") {\r\n            stopRecording();\r\n          }\r\n        };\r\n        \r\n        mediaRecorderRef.current.start(2000); // 2초마다 데이터를 청크로 분할\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(\"마이크 접근 오류:\", error);\r\n      setStatus(\"error\");\r\n    }\r\n  }, [status, onTranscriptReceived, stopRecording]);\r\n\r\n  return { status, startRecording, stopRecording };\r\n}; "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AAIrD,OAAO,MAAMC,cAAc,GAAIC,oBAAkD,IAAK;EAAAC,EAAA;EACpF,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGP,QAAQ,CAAkB,MAAM,CAAC;EAC7D,MAAMQ,gBAAgB,GAAGP,MAAM,CAAuB,IAAI,CAAC;EAC3D,MAAMQ,YAAY,GAAGR,MAAM,CAAmB,IAAI,CAAC;EACnD,MAAMS,cAAc,GAAGT,MAAM,CAAS,EAAE,CAAC;EAEzC,MAAMU,aAAa,GAAGT,WAAW,CAAC,MAAM;IACtC,IAAIM,gBAAgB,CAACI,OAAO,IAAIJ,gBAAgB,CAACI,OAAO,CAACC,KAAK,KAAK,WAAW,EAAE;MAC9EL,gBAAgB,CAACI,OAAO,CAACE,IAAI,CAAC,CAAC;IACjC;IACA,IAAIL,YAAY,CAACG,OAAO,IAAIH,YAAY,CAACG,OAAO,CAACG,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;MAC9ER,YAAY,CAACG,OAAO,CAACM,KAAK,CAAC,CAAC;IAC9B;IACAX,SAAS,CAAC,MAAM,CAAC;EACnB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMY,cAAc,GAAGjB,WAAW,CAAC,YAAY;IAC7C,IAAII,MAAM,KAAK,WAAW,EAAE;MAC1BK,aAAa,CAAC,CAAC;MACf;IACF;IAEAJ,SAAS,CAAC,YAAY,CAAC;IAEvB,IAAI;MACF,MAAMa,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MAEzE,MAAMC,KAAK,GAAGC,OAAO,CAACC,GAAG,CAACC,uBAAuB,IAAI,kCAAkC;MACvF,MAAMC,EAAE,GAAG,IAAIb,SAAS,CAACS,KAAK,CAAC;MAC/BhB,YAAY,CAACG,OAAO,GAAGiB,EAAE;MAEzBA,EAAE,CAACC,MAAM,GAAG,MAAM;QAChBC,OAAO,CAACC,GAAG,CAAC,iBAAiB,CAAC;QAC9BzB,SAAS,CAAC,WAAW,CAAC;QAEtBC,gBAAgB,CAACI,OAAO,GAAG,IAAIqB,aAAa,CAACb,MAAM,EAAE;UAAEc,QAAQ,EAAE;QAAa,CAAC,CAAC;QAChFxB,cAAc,CAACE,OAAO,GAAG,EAAE;QAE3BJ,gBAAgB,CAACI,OAAO,CAACuB,eAAe,GAAIC,KAAK,IAAK;UACpD,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;YACvB5B,cAAc,CAACE,OAAO,CAAC2B,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;YACvC,MAAMG,SAAS,GAAG,IAAIC,IAAI,CAAC/B,cAAc,CAACE,OAAO,EAAE;cAAE8B,IAAI,EAAE;YAAa,CAAC,CAAC;YAC1Eb,EAAE,CAACc,IAAI,CAACH,SAAS,CAAC;YAClB9B,cAAc,CAACE,OAAO,GAAG,EAAE,CAAC,CAAC;UAC/B;QACF,CAAC;QAEDJ,gBAAgB,CAACI,OAAO,CAACgC,MAAM,GAAG,MAAM;UACtCxB,MAAM,CAACyB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACjC,IAAI,CAAC,CAAC,CAAC;UACjD,IAAIe,EAAE,CAACd,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;YACpCY,EAAE,CAACX,KAAK,CAAC,CAAC;UACZ;QACF,CAAC;QAEDW,EAAE,CAACmB,SAAS,GAAIZ,KAAK,IAAK;UACxBhC,oBAAoB,CAACgC,KAAK,CAACC,IAAI,CAAC;QAClC,CAAC;QAEDR,EAAE,CAACoB,OAAO,GAAIC,KAAK,IAAK;UACtBnB,OAAO,CAACmB,KAAK,CAAC,eAAe,EAAEA,KAAK,CAAC;UACrC3C,SAAS,CAAC,OAAO,CAAC;UAClBI,aAAa,CAAC,CAAC;QACjB,CAAC;QAEDkB,EAAE,CAACsB,OAAO,GAAG,MAAM;UACjBpB,OAAO,CAACC,GAAG,CAAC,iBAAiB,CAAC;UAC9BzB,SAAS,CAAC,MAAM,CAAC;UACjB,IAAIC,gBAAgB,CAACI,OAAO,IAAIJ,gBAAgB,CAACI,OAAO,CAACC,KAAK,KAAK,WAAW,EAAE;YAC9EF,aAAa,CAAC,CAAC;UACjB;QACF,CAAC;QAEDH,gBAAgB,CAACI,OAAO,CAACwC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;MACxC,CAAC;IAEH,CAAC,CAAC,OAAOF,KAAK,EAAE;MACdnB,OAAO,CAACmB,KAAK,CAAC,YAAY,EAAEA,KAAK,CAAC;MAClC3C,SAAS,CAAC,OAAO,CAAC;IACpB;EACF,CAAC,EAAE,CAACD,MAAM,EAAEF,oBAAoB,EAAEO,aAAa,CAAC,CAAC;EAEjD,OAAO;IAAEL,MAAM;IAAEa,cAAc;IAAER;EAAc,CAAC;AAClD,CAAC;AAACN,EAAA,CAlFWF,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}