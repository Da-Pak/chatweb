{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sungh\\\\Desktop\\\\chat_work\\\\frontend\\\\src\\\\features\\\\training\\\\components\\\\SentenceView.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport TrainingChatView from '../../shared/components/TrainingChatView';\nimport { chatApi } from '../../shared/api/chatApi';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SentenceView = ({\n  personaId,\n  personaName,\n  sentenceContent,\n  threads,\n  onThreadUpdate,\n  onSwitchToMode,\n  onGenerateNewInterpretation,\n  selectedThread: propSelectedThread\n}) => {\n  _s();\n  var _selectedThread$messa;\n  const [selectedThread, setSelectedThread] = useState(propSelectedThread || null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [localThreads, setLocalThreads] = useState(threads);\n\n  // 문장 타입의 스레드만 필터링\n  const sentenceThreads = localThreads.filter(thread => thread.thread_type === 'sentence');\n  useEffect(() => {\n    setLocalThreads(threads);\n  }, [threads]);\n\n  // propSelectedThread가 변경되면 선택된 스레드 업데이트\n  useEffect(() => {\n    if (propSelectedThread) {\n      setSelectedThread(propSelectedThread);\n    } else {\n      // 첫 번째 문장 스레드를 자동 선택\n      const firstSentenceThread = threads.find(t => t.thread_type === 'sentence');\n      if (firstSentenceThread && !selectedThread) {\n        setSelectedThread(firstSentenceThread);\n      }\n    }\n  }, [propSelectedThread, threads]);\n  const handleSendMessage = async message => {\n    if (!selectedThread) return false;\n    setIsLoading(true);\n    try {\n      const response = await chatApi.chatWithThread({\n        thread_id: selectedThread.id,\n        user_message: message\n      });\n      if (response.data && response.data.response) {\n        // 스레드 업데이트\n        const updatedThreads = localThreads.map(t => t.id === selectedThread.id ? {\n          ...t,\n          messages: [...t.messages, {\n            role: 'user',\n            content: message,\n            timestamp: new Date().toISOString()\n          }, response.data.response],\n          updated_at: new Date().toISOString()\n        } : t);\n        setLocalThreads(updatedThreads);\n        onThreadUpdate(updatedThreads);\n\n        // 선택된 스레드 업데이트\n        const updatedThread = updatedThreads.find(t => t.id === selectedThread.id);\n        if (updatedThread) {\n          setSelectedThread(updatedThread);\n        }\n        setIsLoading(false);\n        return true;\n      } else {\n        setIsLoading(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('문장 채팅 오류:', error);\n      setIsLoading(false);\n      return false;\n    }\n  };\n  const handleEditMessage = async (messageIndex, newContent) => {\n    if (!selectedThread) return false;\n    setIsLoading(true);\n    try {\n      // 메시지 수정 후 새로운 응답 생성\n      const updatedMessages = [...selectedThread.messages];\n      if (messageIndex >= 0 && messageIndex < updatedMessages.length) {\n        // 수정된 메시지 업데이트\n        updatedMessages[messageIndex] = {\n          ...updatedMessages[messageIndex],\n          content: newContent,\n          timestamp: new Date().toISOString()\n        };\n\n        // 수정된 메시지 이후의 모든 메시지들 제거\n        const filteredMessages = updatedMessages.slice(0, messageIndex + 1);\n\n        // 새로운 AI 응답 생성\n        const response = await chatApi.chatWithThread({\n          thread_id: selectedThread.id,\n          user_message: newContent\n        });\n        if (response.data && response.data.response) {\n          const newMessages = [...filteredMessages, response.data.response];\n\n          // 스레드 업데이트\n          const updatedThreads = localThreads.map(t => t.id === selectedThread.id ? {\n            ...t,\n            messages: newMessages,\n            updated_at: new Date().toISOString()\n          } : t);\n          setLocalThreads(updatedThreads);\n          onThreadUpdate(updatedThreads);\n\n          // 선택된 스레드 업데이트\n          const updatedThread = updatedThreads.find(t => t.id === selectedThread.id);\n          if (updatedThread) {\n            setSelectedThread(updatedThread);\n          }\n          setIsLoading(false);\n          return true;\n        }\n      }\n      setIsLoading(false);\n      return false;\n    } catch (error) {\n      console.error('문장 메시지 수정 실패:', error);\n      setIsLoading(false);\n      return false;\n    }\n  };\n  const handleGenerateNewSentence = async () => {\n    if (!selectedThread || selectedThread.messages.length === 0) {\n      if (onGenerateNewInterpretation) {\n        onGenerateNewInterpretation();\n      }\n      return;\n    }\n    setIsLoading(true);\n    try {\n      // 현재 스레드의 최신 assistant 메시지를 기반으로 새로운 문장 생성\n      const latestAssistantMessage = [...selectedThread.messages].reverse().find(msg => msg.role === 'assistant');\n      if (latestAssistantMessage) {\n        const response = await chatApi.generateSentence({\n          persona_id: personaId,\n          interpretation_content: latestAssistantMessage.content\n        });\n        if (response.data && response.data.sentence_content) {\n          // 스레드 목록 새로고침\n          try {\n            const threadsResponse = await chatApi.getPersonaThreads(personaId);\n            if (threadsResponse.data) {\n              const updatedThreads = threadsResponse.data;\n              setLocalThreads(updatedThreads);\n              onThreadUpdate(updatedThreads);\n\n              // 새로 생성된 문장 스레드 선택\n              const newSentenceThread = updatedThreads.filter(t => t.thread_type === 'sentence').sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0];\n              if (newSentenceThread) {\n                setSelectedThread(newSentenceThread);\n              }\n            }\n          } catch (refreshError) {\n            console.error('스레드 새로고침 실패:', refreshError);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('문장 생성 오류:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const handleSwitchToMode = mode => {\n    if (onSwitchToMode) {\n      onSwitchToMode(mode);\n    }\n  };\n\n  // 현재 선택된 스레드의 메시지들 또는 빈 배열\n  const currentMessages = (selectedThread === null || selectedThread === void 0 ? void 0 : selectedThread.messages) || [];\n\n  // 첫 번째 문장 내용 (스레드가 없거나 메시지가 없는 경우)\n  const displayContent = (selectedThread === null || selectedThread === void 0 ? void 0 : (_selectedThread$messa = selectedThread.messages.find(m => m.role === 'assistant')) === null || _selectedThread$messa === void 0 ? void 0 : _selectedThread$messa.content) || sentenceContent;\n  return /*#__PURE__*/_jsxDEV(TrainingChatView, {\n    personaId: personaId,\n    personaName: personaName,\n    contextContent: displayContent,\n    contextType: \"sentence\",\n    messages: currentMessages,\n    isLoading: isLoading,\n    onSendMessage: handleSendMessage,\n    onEditMessage: handleEditMessage,\n    onGenerateNewContent: handleGenerateNewSentence,\n    onSwitchToMode: handleSwitchToMode\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 223,\n    columnNumber: 5\n  }, this);\n};\n_s(SentenceView, \"2aTql3Fze190BW+PsdbgruoF2to=\");\n_c = SentenceView;\nexport default SentenceView;\nvar _c;\n$RefreshReg$(_c, \"SentenceView\");","map":{"version":3,"names":["React","useState","useEffect","TrainingChatView","chatApi","jsxDEV","_jsxDEV","SentenceView","personaId","personaName","sentenceContent","threads","onThreadUpdate","onSwitchToMode","onGenerateNewInterpretation","selectedThread","propSelectedThread","_s","_selectedThread$messa","setSelectedThread","isLoading","setIsLoading","localThreads","setLocalThreads","sentenceThreads","filter","thread","thread_type","firstSentenceThread","find","t","handleSendMessage","message","response","chatWithThread","thread_id","id","user_message","data","updatedThreads","map","messages","role","content","timestamp","Date","toISOString","updated_at","updatedThread","error","console","handleEditMessage","messageIndex","newContent","updatedMessages","length","filteredMessages","slice","newMessages","handleGenerateNewSentence","latestAssistantMessage","reverse","msg","generateSentence","persona_id","interpretation_content","sentence_content","threadsResponse","getPersonaThreads","newSentenceThread","sort","a","b","created_at","getTime","refreshError","handleSwitchToMode","mode","currentMessages","displayContent","m","contextContent","contextType","onSendMessage","onEditMessage","onGenerateNewContent","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/sungh/Desktop/chat_work/frontend/src/features/training/components/SentenceView.tsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport TrainingChatView from '../../shared/components/TrainingChatView';\nimport { chatApi } from '../../shared/api/chatApi';\nimport { TrainingThread } from '../../shared/types';\n\ninterface SentenceViewProps {\n  personaId: string;\n  personaName: string;\n  sentenceContent: string;\n  threads: TrainingThread[];\n  onThreadUpdate: (threads: TrainingThread[]) => void;\n  onSwitchToMode?: (mode: 'interpretation' | 'proceed') => void;\n  onGenerateNewInterpretation?: () => void;\n  selectedThread?: TrainingThread | null;\n}\n\nconst SentenceView: React.FC<SentenceViewProps> = ({\n  personaId,\n  personaName,\n  sentenceContent,\n  threads,\n  onThreadUpdate,\n  onSwitchToMode,\n  onGenerateNewInterpretation,\n  selectedThread: propSelectedThread,\n}) => {\n  const [selectedThread, setSelectedThread] = useState<TrainingThread | null>(propSelectedThread || null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [localThreads, setLocalThreads] = useState<TrainingThread[]>(threads);\n\n  // 문장 타입의 스레드만 필터링\n  const sentenceThreads = localThreads.filter(thread => thread.thread_type === 'sentence');\n\n  useEffect(() => {\n    setLocalThreads(threads);\n  }, [threads]);\n\n  // propSelectedThread가 변경되면 선택된 스레드 업데이트\n  useEffect(() => {\n    if (propSelectedThread) {\n      setSelectedThread(propSelectedThread);\n    } else {\n      // 첫 번째 문장 스레드를 자동 선택\n      const firstSentenceThread = threads.find(t => t.thread_type === 'sentence');\n      if (firstSentenceThread && !selectedThread) {\n        setSelectedThread(firstSentenceThread);\n      }\n    }\n  }, [propSelectedThread, threads]);\n\n  const handleSendMessage = async (message: string): Promise<boolean> => {\n    if (!selectedThread) return false;\n\n    setIsLoading(true);\n    try {\n      const response = await chatApi.chatWithThread({\n        thread_id: selectedThread.id,\n        user_message: message\n      });\n\n      if (response.data && response.data.response) {\n        // 스레드 업데이트\n        const updatedThreads = localThreads.map(t => \n          t.id === selectedThread.id \n            ? {\n                ...t,\n                messages: [...t.messages, \n                  {\n                    role: 'user' as const,\n                    content: message,\n                    timestamp: new Date().toISOString()\n                  },\n                  response.data!.response\n                ],\n                updated_at: new Date().toISOString()\n              }\n            : t\n        );\n        \n        setLocalThreads(updatedThreads);\n        onThreadUpdate(updatedThreads);\n        \n        // 선택된 스레드 업데이트\n        const updatedThread = updatedThreads.find(t => t.id === selectedThread.id);\n        if (updatedThread) {\n          setSelectedThread(updatedThread);\n        }\n        \n        setIsLoading(false);\n        return true;\n      } else {\n        setIsLoading(false);\n        return false;\n      }\n    } catch (error) {\n      console.error('문장 채팅 오류:', error);\n      setIsLoading(false);\n      return false;\n    }\n  };\n\n  const handleEditMessage = async (messageIndex: number, newContent: string): Promise<boolean> => {\n    if (!selectedThread) return false;\n\n    setIsLoading(true);\n    try {\n      // 메시지 수정 후 새로운 응답 생성\n      const updatedMessages = [...selectedThread.messages];\n      if (messageIndex >= 0 && messageIndex < updatedMessages.length) {\n        // 수정된 메시지 업데이트\n        updatedMessages[messageIndex] = {\n          ...updatedMessages[messageIndex],\n          content: newContent,\n          timestamp: new Date().toISOString(),\n        };\n\n        // 수정된 메시지 이후의 모든 메시지들 제거\n        const filteredMessages = updatedMessages.slice(0, messageIndex + 1);\n\n        // 새로운 AI 응답 생성\n        const response = await chatApi.chatWithThread({\n          thread_id: selectedThread.id,\n          user_message: newContent\n        });\n\n        if (response.data && response.data.response) {\n          const newMessages = [...filteredMessages, response.data.response];\n          \n          // 스레드 업데이트\n          const updatedThreads = localThreads.map(t => \n            t.id === selectedThread.id \n              ? { ...t, messages: newMessages, updated_at: new Date().toISOString() }\n              : t\n          );\n          \n          setLocalThreads(updatedThreads);\n          onThreadUpdate(updatedThreads);\n          \n          // 선택된 스레드 업데이트\n          const updatedThread = updatedThreads.find(t => t.id === selectedThread.id);\n          if (updatedThread) {\n            setSelectedThread(updatedThread);\n          }\n          \n          setIsLoading(false);\n          return true;\n        }\n      }\n      \n      setIsLoading(false);\n      return false;\n    } catch (error) {\n      console.error('문장 메시지 수정 실패:', error);\n      setIsLoading(false);\n      return false;\n    }\n  };\n\n  const handleGenerateNewSentence = async () => {\n    if (!selectedThread || selectedThread.messages.length === 0) {\n      if (onGenerateNewInterpretation) {\n        onGenerateNewInterpretation();\n      }\n      return;\n    }\n    \n    setIsLoading(true);\n    try {\n      // 현재 스레드의 최신 assistant 메시지를 기반으로 새로운 문장 생성\n      const latestAssistantMessage = [...selectedThread.messages]\n        .reverse()\n        .find(msg => msg.role === 'assistant');\n      \n      if (latestAssistantMessage) {\n        const response = await chatApi.generateSentence({\n          persona_id: personaId,\n          interpretation_content: latestAssistantMessage.content\n        });\n\n        if (response.data && response.data.sentence_content) {\n          // 스레드 목록 새로고침\n          try {\n            const threadsResponse = await chatApi.getPersonaThreads(personaId);\n            if (threadsResponse.data) {\n              const updatedThreads = threadsResponse.data;\n              setLocalThreads(updatedThreads);\n              onThreadUpdate(updatedThreads);\n              \n              // 새로 생성된 문장 스레드 선택\n              const newSentenceThread = updatedThreads\n                .filter(t => t.thread_type === 'sentence')\n                .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0];\n              \n              if (newSentenceThread) {\n                setSelectedThread(newSentenceThread);\n              }\n            }\n          } catch (refreshError) {\n            console.error('스레드 새로고침 실패:', refreshError);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('문장 생성 오류:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleSwitchToMode = (mode: 'interpretation' | 'proceed' | 'sentence') => {\n    if (onSwitchToMode) {\n      onSwitchToMode(mode as 'interpretation' | 'proceed');\n    }\n  };\n\n  // 현재 선택된 스레드의 메시지들 또는 빈 배열\n  const currentMessages = selectedThread?.messages || [];\n\n  // 첫 번째 문장 내용 (스레드가 없거나 메시지가 없는 경우)\n  const displayContent = selectedThread?.messages.find(m => m.role === 'assistant')?.content || sentenceContent;\n\n  return (\n    <TrainingChatView\n      personaId={personaId}\n      personaName={personaName}\n      contextContent={displayContent}\n      contextType=\"sentence\"\n      messages={currentMessages}\n      isLoading={isLoading}\n      onSendMessage={handleSendMessage}\n      onEditMessage={handleEditMessage}\n      onGenerateNewContent={handleGenerateNewSentence}\n      onSwitchToMode={handleSwitchToMode}\n    />\n  );\n};\n\nexport default SentenceView; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}