{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { sentenceApi } from '../../training/api/sentenceApi';\nexport const useSentenceData = threadId => {\n  _s();\n  const [memos, setMemos] = useState({});\n  const [highlightedSentences, setHighlightedSentences] = useState(new Set());\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // 스레드별 메모/하이라이트 데이터 로딩\n  useEffect(() => {\n    if (threadId) {\n      loadThreadSentenceData();\n    }\n  }, [threadId]);\n  const loadThreadSentenceData = async () => {\n    if (!threadId) return;\n    console.log('=== 스레드 문장 데이터 로딩 시작 ===');\n    console.log('대상 스레드 ID:', threadId);\n    setIsLoading(true);\n    setError(null);\n    try {\n      var _data$highlights;\n      const data = await sentenceApi.getThreadSentenceData(threadId);\n      console.log('로딩된 데이터:', {\n        memo_count: Object.keys(data.memos || {}).length,\n        highlight_count: ((_data$highlights = data.highlights) === null || _data$highlights === void 0 ? void 0 : _data$highlights.length) || 0,\n        memos: data.memos,\n        highlights: data.highlights\n      });\n      setMemos(data.memos || {});\n      setHighlightedSentences(new Set(data.highlights || []));\n      console.log('스레드 문장 데이터 로딩 완료');\n    } catch (error) {\n      console.error('스레드 문장 데이터 로딩 실패:', error);\n      setError(error instanceof Error ? error.message : '데이터 로딩에 실패했습니다');\n\n      // 실패 시 빈 상태로 초기화\n      setMemos({});\n      setHighlightedSentences(new Set());\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const handleMemoChange = async (sentenceId, memo, threadId, threadType, sentenceContent) => {\n    console.log('=== 메모 변경 처리 시작 ===');\n    console.log('문장 ID:', sentenceId);\n    console.log('메모 내용:', memo.substring(0, 50) + (memo.length > 50 ? '...' : ''));\n    console.log('스레드 ID:', threadId);\n    console.log('스레드 타입:', threadType);\n    try {\n      // 로컬 상태에서 메모 즉시 업데이트 (UI 반응성)\n      setMemos(prev => ({\n        ...prev,\n        [sentenceId]: memo\n      }));\n\n      // 백엔드 API 호출\n      const response = await sentenceApi.createOrUpdateMemo({\n        sentence_id: sentenceId,\n        thread_id: threadId,\n        thread_type: threadType,\n        content: memo,\n        sentence_content: sentenceContent\n      });\n      console.log('메모 저장 API 응답:', response);\n      console.log('메모 변경 처리 완료');\n      return response;\n    } catch (error) {\n      console.error('메모 저장 실패:', error);\n\n      // 실패 시 원래 상태로 되돌리기\n      setMemos(prev => {\n        const newMemos = {\n          ...prev\n        };\n        if (memo.trim() === '') {\n          delete newMemos[sentenceId];\n        } else {\n          // 이전 상태를 복원하기 어려우므로 다시 로딩\n          loadThreadSentenceData();\n        }\n        return newMemos;\n      });\n      throw error;\n    }\n  };\n  const handleDeleteMemo = async sentenceId => {\n    console.log('=== 메모 삭제 처리 시작 ===');\n    console.log('문장 ID:', sentenceId);\n    try {\n      // 로컬 상태에서 메모 즉시 제거 (UI 반응성)\n      const previousMemo = memos[sentenceId];\n      setMemos(prev => {\n        const newMemos = {\n          ...prev\n        };\n        delete newMemos[sentenceId];\n        return newMemos;\n      });\n\n      // 백엔드 API 호출\n      const response = await sentenceApi.deleteMemo(sentenceId);\n      console.log('메모 삭제 API 응답:', response);\n      console.log('메모 삭제 처리 완료');\n      return response;\n    } catch (error) {\n      console.error('메모 삭제 실패:', error);\n\n      // 실패 시 원래 상태로 되돌리기\n      if (memos[sentenceId] !== undefined) {\n        setMemos(prev => ({\n          ...prev,\n          [sentenceId]: memos[sentenceId]\n        }));\n      }\n      throw error;\n    }\n  };\n  const handleToggleHighlight = async (sentenceId, threadId, threadType) => {\n    console.log('=== 하이라이트 토글 처리 시작 ===');\n    console.log('문장 ID:', sentenceId);\n    console.log('현재 하이라이트 상태:', highlightedSentences.has(sentenceId));\n    const isCurrentlyHighlighted = highlightedSentences.has(sentenceId);\n    try {\n      // 로컬 상태에서 하이라이트 즉시 토글 (UI 반응성)\n      setHighlightedSentences(prev => {\n        const newSet = new Set(prev);\n        if (isCurrentlyHighlighted) {\n          newSet.delete(sentenceId);\n        } else {\n          newSet.add(sentenceId);\n        }\n        return newSet;\n      });\n\n      // 백엔드 API 호출\n      let response;\n      if (isCurrentlyHighlighted) {\n        response = await sentenceApi.deleteHighlight(sentenceId);\n      } else {\n        // threadId와 threadType이 없으면 빈 문자열로 처리\n        response = await sentenceApi.createHighlight({\n          sentence_id: sentenceId,\n          thread_id: threadId || '',\n          thread_type: threadType || ''\n        });\n      }\n      console.log('하이라이트 토글 API 응답:', response);\n      console.log('하이라이트 토글 처리 완료');\n      return response;\n    } catch (error) {\n      console.error('하이라이트 토글 실패:', error);\n\n      // 실패 시 원래 상태로 되돌리기\n      setHighlightedSentences(prev => {\n        const newSet = new Set(prev);\n        if (isCurrentlyHighlighted) {\n          newSet.add(sentenceId);\n        } else {\n          newSet.delete(sentenceId);\n        }\n        return newSet;\n      });\n      throw error;\n    }\n  };\n  return {\n    memos,\n    highlightedSentences,\n    isLoading,\n    error,\n    loadThreadSentenceData,\n    handleMemoChange,\n    handleDeleteMemo,\n    handleToggleHighlight,\n    setMemos,\n    setHighlightedSentences\n  };\n};\n_s(useSentenceData, \"5UGXifDmjxfirJHe9gpJoeQ1Q2U=\");","map":{"version":3,"names":["useState","useEffect","sentenceApi","useSentenceData","threadId","_s","memos","setMemos","highlightedSentences","setHighlightedSentences","Set","isLoading","setIsLoading","error","setError","loadThreadSentenceData","console","log","_data$highlights","data","getThreadSentenceData","memo_count","Object","keys","length","highlight_count","highlights","Error","message","handleMemoChange","sentenceId","memo","threadType","sentenceContent","substring","prev","response","createOrUpdateMemo","sentence_id","thread_id","thread_type","content","sentence_content","newMemos","trim","handleDeleteMemo","previousMemo","deleteMemo","undefined","handleToggleHighlight","has","isCurrentlyHighlighted","newSet","delete","add","deleteHighlight","createHighlight"],"sources":["C:/Users/sungh/Desktop/chat_work_ver4/frontend/src/features/shared/hooks/useSentenceData.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { sentenceApi } from '../../training/api/sentenceApi';\r\n\r\nexport const useSentenceData = (threadId?: string) => {\r\n  const [memos, setMemos] = useState<Record<string, string>>({});\r\n  const [highlightedSentences, setHighlightedSentences] = useState<Set<string>>(new Set());\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // 스레드별 메모/하이라이트 데이터 로딩\r\n  useEffect(() => {\r\n    if (threadId) {\r\n      loadThreadSentenceData();\r\n    }\r\n  }, [threadId]);\r\n\r\n  const loadThreadSentenceData = async () => {\r\n    if (!threadId) return;\r\n    \r\n    console.log('=== 스레드 문장 데이터 로딩 시작 ===');\r\n    console.log('대상 스레드 ID:', threadId);\r\n    \r\n    setIsLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const data = await sentenceApi.getThreadSentenceData(threadId);\r\n      \r\n      console.log('로딩된 데이터:', {\r\n        memo_count: Object.keys(data.memos || {}).length,\r\n        highlight_count: data.highlights?.length || 0,\r\n        memos: data.memos,\r\n        highlights: data.highlights\r\n      });\r\n      \r\n      setMemos(data.memos || {});\r\n      setHighlightedSentences(new Set(data.highlights || []));\r\n      \r\n      console.log('스레드 문장 데이터 로딩 완료');\r\n    } catch (error) {\r\n      console.error('스레드 문장 데이터 로딩 실패:', error);\r\n      setError(error instanceof Error ? error.message : '데이터 로딩에 실패했습니다');\r\n      \r\n      // 실패 시 빈 상태로 초기화\r\n      setMemos({});\r\n      setHighlightedSentences(new Set());\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleMemoChange = async (\r\n    sentenceId: string, \r\n    memo: string, \r\n    threadId?: string, \r\n    threadType?: string,\r\n    sentenceContent?: string\r\n  ) => {\r\n    console.log('=== 메모 변경 처리 시작 ===');\r\n    console.log('문장 ID:', sentenceId);\r\n    console.log('메모 내용:', memo.substring(0, 50) + (memo.length > 50 ? '...' : ''));\r\n    console.log('스레드 ID:', threadId);\r\n    console.log('스레드 타입:', threadType);\r\n    \r\n    try {\r\n      // 로컬 상태에서 메모 즉시 업데이트 (UI 반응성)\r\n      setMemos(prev => ({\r\n        ...prev,\r\n        [sentenceId]: memo\r\n      }));\r\n      \r\n      // 백엔드 API 호출\r\n      const response = await sentenceApi.createOrUpdateMemo({\r\n        sentence_id: sentenceId,\r\n        thread_id: threadId,\r\n        thread_type: threadType,\r\n        content: memo,\r\n        sentence_content: sentenceContent\r\n      });\r\n      \r\n      console.log('메모 저장 API 응답:', response);\r\n      console.log('메모 변경 처리 완료');\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('메모 저장 실패:', error);\r\n      \r\n      // 실패 시 원래 상태로 되돌리기\r\n      setMemos(prev => {\r\n        const newMemos = { ...prev };\r\n        if (memo.trim() === '') {\r\n          delete newMemos[sentenceId];\r\n        } else {\r\n          // 이전 상태를 복원하기 어려우므로 다시 로딩\r\n          loadThreadSentenceData();\r\n        }\r\n        return newMemos;\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const handleDeleteMemo = async (sentenceId: string) => {\r\n    console.log('=== 메모 삭제 처리 시작 ===');\r\n    console.log('문장 ID:', sentenceId);\r\n    \r\n    try {\r\n      // 로컬 상태에서 메모 즉시 제거 (UI 반응성)\r\n      const previousMemo = memos[sentenceId];\r\n      setMemos(prev => {\r\n        const newMemos = { ...prev };\r\n        delete newMemos[sentenceId];\r\n        return newMemos;\r\n      });\r\n      \r\n      // 백엔드 API 호출\r\n      const response = await sentenceApi.deleteMemo(sentenceId);\r\n      \r\n      console.log('메모 삭제 API 응답:', response);\r\n      console.log('메모 삭제 처리 완료');\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('메모 삭제 실패:', error);\r\n      \r\n      // 실패 시 원래 상태로 되돌리기\r\n      if (memos[sentenceId] !== undefined) {\r\n        setMemos(prev => ({\r\n          ...prev,\r\n          [sentenceId]: memos[sentenceId]\r\n        }));\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const handleToggleHighlight = async (\r\n    sentenceId: string, \r\n    threadId?: string, \r\n    threadType?: string\r\n  ) => {\r\n    console.log('=== 하이라이트 토글 처리 시작 ===');\r\n    console.log('문장 ID:', sentenceId);\r\n    console.log('현재 하이라이트 상태:', highlightedSentences.has(sentenceId));\r\n    \r\n    const isCurrentlyHighlighted = highlightedSentences.has(sentenceId);\r\n    \r\n    try {\r\n      // 로컬 상태에서 하이라이트 즉시 토글 (UI 반응성)\r\n      setHighlightedSentences(prev => {\r\n        const newSet = new Set(prev);\r\n        if (isCurrentlyHighlighted) {\r\n          newSet.delete(sentenceId);\r\n        } else {\r\n          newSet.add(sentenceId);\r\n        }\r\n        return newSet;\r\n      });\r\n      \r\n      // 백엔드 API 호출\r\n      let response;\r\n      if (isCurrentlyHighlighted) {\r\n        response = await sentenceApi.deleteHighlight(sentenceId);\r\n      } else {\r\n        // threadId와 threadType이 없으면 빈 문자열로 처리\r\n        response = await sentenceApi.createHighlight({\r\n          sentence_id: sentenceId,\r\n          thread_id: threadId || '',\r\n          thread_type: threadType || ''\r\n        });\r\n      }\r\n      \r\n      console.log('하이라이트 토글 API 응답:', response);\r\n      console.log('하이라이트 토글 처리 완료');\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      console.error('하이라이트 토글 실패:', error);\r\n      \r\n      // 실패 시 원래 상태로 되돌리기\r\n      setHighlightedSentences(prev => {\r\n        const newSet = new Set(prev);\r\n        if (isCurrentlyHighlighted) {\r\n          newSet.add(sentenceId);\r\n        } else {\r\n          newSet.delete(sentenceId);\r\n        }\r\n        return newSet;\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  };\r\n\r\n  return {\r\n    memos,\r\n    highlightedSentences,\r\n    isLoading,\r\n    error,\r\n    loadThreadSentenceData,\r\n    handleMemoChange,\r\n    handleDeleteMemo,\r\n    handleToggleHighlight,\r\n    setMemos,\r\n    setHighlightedSentences\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}